<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[牛牛龙]]></title>
  <link href="http://yulongniu.bionutshell.org/atom.xml" rel="self"/>
  <link href="http://yulongniu.bionutshell.org/"/>
  <updated>2017-12-05T01:41:11+08:00</updated>
  <id>http://yulongniu.bionutshell.org/</id>
  <author>
    <name><![CDATA[Yulong Niu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bray-Curtis Distance解释]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2017/10/24/bray-curtis-distance/"/>
    <updated>2017-10-24T12:26:00+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2017/10/24/bray-curtis-distance</id>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

<script type="math/tex; mode=display">\newcommand{\sumup}[1] {\sum\limits_{i=1}^{n} #1}</script>

<p>Bray-Curtis distance（BCD）的定义为：</p>

<!--more-->

<script type="math/tex; mode=display">\begin{align}
\begin{split}
BCD(X, Y) = \frac{\sumup{|x_i - y_j|}}{\sumup{x_i} + \sumup{y_i}}
\end{split}
\label{eq:1}
\end{align}</script>

<p>其中，$X$和$Y$分别为长度为$n$的数值向量。根据$\eqref{eq:1}$可以得出：$BCD$的取值范围为$[0, 1]$；当$X$和$Y$完全相同时，$BCD$为0；反之，$BCD$为1。</p>

<p>同样，Bray-Curtis similarity（BCS）或Bray-Curtis index为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
BCS(X, Y) = 1 - BCD(X, Y)
\end{split}
\label{eq:2}
\end{align}</script>

<h3 id="section">参考资料</h3>

<ul>
  <li><a href="http://84.89.132.1/~michael/stanford/maeb6.pdf">Chapter 6 Measures of distance and correlation between variables</a></li>
</ul>

<h3 id="section-1">更新记录</h3>

<p>2017年10月22日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Normalized Google Distance解释]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2017/10/22/google-distance/"/>
    <updated>2017-10-22T21:35:30+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2017/10/22/google-distance</id>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

<script type="math/tex; mode=display">\newcommand{\sumup}[1] {\sum\limits_{i=1}^{n} #1}</script>

<p>本文尝试探索Normalized Google distance（简称NGD）的定义和拓展应用。</p>

<h3 id="ngd">1. NGD原始定义</h3>

<p><a href="https://en.wikipedia.org/wiki/Normalized_Google_distance">维基百科</a>的定义为：</p>

<!--more-->

<script type="math/tex; mode=display">\begin{align}
\begin{split}
NGD(x, y) = \frac{\max\{\log f(x), \log f(y)\} - \log f(x, y)}{\log N - \min\{\log f(x), \log f(y)\}}
\end{split}
\label{eq:1}
\end{align}</script>

<p>其中，$f(x)$和$f(y)$分别为关键词$x$和$y$出现的次数，$f(x,y)$为$x$和$y$同时出现的次数，$N$为全部搜索单词数目。根据$\eqref{eq:1}$可以得出：如果$x$和$y$几乎总是同时出现时，$NGD$趋近于$0$；如果$x$和$y$出现的次数很少，即$\log f(x,y)$趋近于负无穷，则$NGD$可能大于$1$。</p>

<h3 id="ngd-1">2. NGD定义延伸</h3>

<p>Choi and Rashid在2008年的文章（参考资料1）提出一种针对向量的$NGD$定义：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
NGD(X, Y) &= \frac{\max\left\{\sumup{x_i}, \sumup{y_i}\right\} - \sumup{\min(x_i, y_i)}}{\sumup{x_i} + \sumup{y_i} - \sumup{\min(x_i, y_i)}} \\
&= \frac{\max\left\{\sumup{x_i}, \sumup{y_i}\right\} - \sumup{\min(x_i, y_i)}}{\max\left\{\sumup{x_i}, \sumup{y_i}\right\}}
\end{split}
\label{eq:2}
\end{align} %]]&gt;</script>

<p>其中，$X$和$Y$分别为长度为$n$的数值向量，$\min(x_i, y_i)$为$x_i$和$y_i$中各个元素最小值所组成的数值向量。根据$\eqref{eq:2}$可以得出：$NGD$的取值范围为$[0, 1]$；当$X$和$Y$完全相同时，$NGD$为0；反之，$NGD$为1。</p>

<p>由此，可以得到normalized Google similarity（NGS）为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
NGS(X, Y) &= 1 - NGD(X, Y) \\
&= \frac{\sumup{\min(x_i, y_i)}}{\max\left\{\sumup{x_i}, \sumup{y_i}\right\}}
\end{split}
\label{eq:3}
\end{align} %]]&gt;</script>

<p>一个例子：$X = (1, 2, 0, 3)$和$Y = (0, 2, 1, 1)$，则$NGD = 0.5$和$NGS = 0.5$。</p>

<h3 id="section">参考资料</h3>

<ul>
  <li><a href="https://www.cs.cmu.edu/afs/cs/user/aberger/www/html/tutorial/tutorial.html">Adapting Normalized Google Similarity in Protein Sequence Comparison</a></li>
</ul>

<h3 id="section-1">更新记录</h3>

<p>2017年10月21日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最大熵模型]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2017/10/16/max-entropy/"/>
    <updated>2017-10-16T13:16:12+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2017/10/16/max-entropy</id>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

<h3 id="section">1. 熵和条件熵</h3>

<p>对于随机变量$X$，熵为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
H(X) = -\sum_{x \in X}p(x)\log{p(x)}
\end{split}
\label{eq:1}
\end{align}</script>

<!--more-->

<p>其中：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
\sum_{x \in X}p(x) = 1
\end{split}
\label{eq:2}
\end{align}</script>

<p>同样道理，对于任意随机变量$X$和$Y$，联合熵为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
H(X,Y) = -\sum_{x \in X, y \in Y}p(x,y)\log{p(x,y)}
\end{split}
\label{eq:3}
\end{align}</script>

<p>基于$X$的$Y$的熵为条件熵：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
H(Y|X) &= H(X, Y) - H(X) \\
&= -\sum_{x \in X, y \in Y}p(x,y)\log{p(x,y)} + \sum_{x \in X}p(x)\log{p(x)} \\
&= -\sum_{x \in X, y \in Y}p(x,y)\log{p(x,y)} + \sum_{x \in X, y \in Y}p(x, y)\log{p(x)} \\
&= -\sum_{x \in X, y \in Y}p(x, y)\log \frac{p(x, y)}{p(x)}
\end{split}
\label{eq:4}
\end{align} %]]&gt;</script>

<h3 id="section-1">2. 最大熵原理简介</h3>

<p>最大熵原理可以表述为，在满足$k+1$个约束条件的模型集合中，选取熵$H(p)$最大的模型。约束条件为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
\sum_{x}p(x) &= 1 \\
\sum_{x}p(x)f_1(x) &= \tau_1 \\
\vdots \\
\sum_{x}p(x)f_k(x) &= \tau_k
\end{split}
\label{eq:5}
\end{align} %]]&gt;</script>

<p>使用拉格朗日乘子法求解带上述有约束的极值，即：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\begin{split}
L(p) = -\sum_{x}p(x)\log{p(x)} &+ \\
\lambda_0(\sum_{x}p(x) - 1) &+ \\
\lambda_1(\sum_{x}p(x)f_1(x) - \tau_1) &+ \\
\cdots &+\\
\lambda_k(\sum_{x}p(x)f_1(x) - \tau_k)
\end{split}
\end{align*} %]]&gt;</script>

<p>$L(p)$对每一个$p(x)$偏导数$\frac{\partial L(p)}{\partial p(x)}$为0，即：</p>

<script type="math/tex; mode=display">-\log{p(x)} - 1 + \lambda_0 + \sum_{j=1}^{k}\lambda_j f_j(x) = 0</script>

<p>解得</p>

<script type="math/tex; mode=display">p(x) = \frac{\exp\left(\sum\limits_{j=1}^{k}\lambda_j f_j(x)\right)}{\exp(1 - \lambda_0)}</script>

<p>由约束条件$\sum\limits_x p(x)=1$得：</p>

<script type="math/tex; mode=display">\begin{align}
p(x) = \frac{1}{Z}\exp\left(\sum\limits_{j=1}^{k}\lambda_j f_j(x)\right)
\label{eq:6}
\end{align}</script>

<p>其中</p>

<script type="math/tex; mode=display">\begin{align}
Z = \sum\limits_x \exp\left(\sum\limits_{j=1}^{k}\lambda_j f_j(x)\right)
\label{eq:7}
\end{align}</script>

<p>将$\eqref{eq:3}$带入约束条件$\eqref{eq:2}$中，即可解得$\lambda_j$。</p>

<h3 id="section-2">3. 最大熵应用例子</h3>

<p>根据参考资料2的例子，应用最大熵模型。例子简述为：</p>

<blockquote>
  <p>三种食物的售价分别为1、2和3元，平均一餐花费1.75元。</p>

  <p>估算每种食物被购买的概率。</p>
</blockquote>

<p>建立最大熵模型：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\begin{split}
max \quad & H(p) = \sum_{x}p(x) \log p(x) \\
s.t. \quad & \sum_{x}p(x)x = 1.75 \\
\quad & \sum_{x}p(x) = 1
\end{split}
\end{align*} %]]&gt;</script>

<p>解方程得：$p(x_1) = 0.466$、 $p(x_2) = 0.318$、$p(x_3) = 0.216$</p>

<h3 id="section-3">参考资料</h3>

<ul>
  <li>
    <p><a href="https://www.cs.cmu.edu/afs/cs/user/aberger/www/html/tutorial/tutorial.html">A Brief Maxent Tutorial</a></p>
  </li>
  <li>
    <p><a href="http://www-mtl.mit.edu/Courses/6.050/2003/notes/chapter9.pdf">Chapter 9 Principle of Maximum Entropy: Simple Form</a></p>
  </li>
  <li>
    <p><a href="http://spaces.ac.cn/archives/3552/">“熵”不起：从熵、最大熵原理到最大熵模型</a></p>
  </li>
</ul>

<h3 id="section-4">更新记录</h3>

<p>2017年7月15日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[朴素贝叶斯分类器应用于二元数据类型]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2017/10/15/naive-bayes-binary-multinomial/"/>
    <updated>2017-10-15T17:38:16+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2017/10/15/naive-bayes-binary-multinomial</id>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

<h3 id="section">1. 贝叶斯定理</h3>

<p>已知事件$A$和$B$，则条件概率为：</p>

<!--more-->

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
P(A | B) &= \frac{P(A,B)}{P(B)} \\
P(B | A) &= \frac{P(A,B)}{P(A)}
\end{split}
\label{eq:1}
\end{align} %]]&gt;</script>

<p>可以推导出：</p>

<script type="math/tex; mode=display">\begin{align}
P(B|A) = \frac{P(A|B)P(B)}{P(A)}
\label{eq:2}
\end{align}</script>

<h3 id="section-1">2. 分类器简介</h3>

<p>朴素贝叶斯分类器（Naive Bayes classifier）是一种简单、有效的分类器，其难点在于估算条件概率。比如，一个数据集拥有$N$个相互独立的特征，$C$个分组，对于$C_j$条件概率模型为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
p(C_j|F_1,\cdots,F_n) &= \frac{p(F_1,\cdots,F_n|C_j)p(C_j)}{p(F_1,\cdots,F_n)} \\
&= p(F_1|C_j) \cdots p(F_n|C_j)p(C_j)(1/p(F_1,\cdots,F_n))
\end{split}
\label{eq:3}
\end{align} %]]&gt;</script>

<p>由于$1/p(F_1,\cdots,F_n)$在不同分组中为定值，因此：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
p(C_j|F_1,\cdots,F_n) &\propto p(C_j)\prod_{i=1}^{N}p(F_i|C_j)
\end{split}
\label{eq:4}
\end{align} %]]&gt;</script>

<p>其中，$p(C_j)$通常容易求得，即$C_j$分组在测试数据集中出现的频率。而$p(F_i\ \vert C_j)$则根据不同的测试数据类型，有不同的估计值。</p>

<p>以下讨论两种二元数据类型，例如某个数据集有三种特征量：</p>

<script type="math/tex; mode=display">F = 
\left[
\begin{array}{f}
F_1\\
F_2\\
F_3
\end{array}
\right]</script>

<h3 id="section-2">3. 伯努利分布</h3>

<p>每一个特征量的取值都为$0$或$1$。分组$C_j$含有两个已知样本为：</p>

<script type="math/tex; mode=display">C_{j1} = 
\left[
\begin{array}{cj1}
0\\
1\\
0
\end{array}
\right]</script>

<script type="math/tex; mode=display">C_{j2} = 
\left[
\begin{array}{cj2}
0\\
0\\
1
\end{array}
\right]</script>

<p>某个预测样本为：</p>

<script type="math/tex; mode=display">C_{jp1} = 
\left[
\begin{array}{cjp1}
1\\
0\\
1
\end{array}
\right]</script>

<p>由于$p(F_i \vert C_j)$不能为0，根据<a href="https://en.wikipedia.org/wiki/Rule_of_succession">Rule of succession</a>得各个特征的条件概率为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\begin{split}
p(F1|C_j) &= \frac{0+1}{2+2} &= 1/4 \\
p(F2|C_j) &= \frac{1+1}{2+2} &= 1/2 \\
p(F3|C_j) &= \frac{1+1}{2+2} &= 1/2
\end{split}
\end{align*} %]]&gt;</script>

<h3 id="section-3">4. 二项分布</h3>

<p>每一个特征量的取值都一个元素为$0$或$1$的向量（长度可不等）。分组$C_j$含有两个已知样本为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
C_{j1} = 
\left[
\begin{array}{cj1}
0 & 1 & 0 & 1\\
1 & 0 & 1\\
0 & 0
\end{array}
\right] %]]&gt;</script>

<script type="math/tex; mode=display">% &lt;![CDATA[
C_{j2} = 
\left[
\begin{array}{cj2}
0 & 1 & 1 & 1\\
1 & 1 & 1\\
0 & 0
\end{array}
\right] %]]&gt;</script>

<p>某个预测样本为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
C_{jp1} = 
\left[
\begin{array}{cjp1}
0 & 0 & 1 & 1\\
1 & 0 & 1\\
0 & 0
\end{array}
\right] %]]&gt;</script>

<p>各个特征的条件git pull origin master概率为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\begin{split}
p(F1|C_j) &= \left(\frac{3+1}{8+2}\right)^2 \times \left(\frac{5+1}{8+2}\right)^2 \\
p(F2|C_j) &= \left(\frac{5+1}{6+2}\right)^2 \times \left(\frac{1+1}{6+2}\right) \\
p(F3|C_j) &= \left(\frac{4+1}{4+2}\right)^2
\end{split}
\end{align*} %]]&gt;</script>

<h3 id="section-4">优化</h3>

<ol>
  <li>
    <p>当特征较多时，会面临多个小数（$p$值）相乘。可以取对数后再相加，即$\sum\log{p}$。</p>
  </li>
  <li>
    <p>虽然上文讨论的是二元数据，但是朴素贝叶斯分类器也适用于连续或者离散数据类型。</p>
  </li>
</ol>

<h3 id="section-5">参考资料</h3>

<ul>
  <li>
    <p><a href="https://www.inf.ed.ac.uk/teaching/courses/inf2b/learnnotes/inf2b-learn-note07-2up.pdf">Text Classification using Naive Bayes</a></p>
  </li>
  <li>
    <p><a href="https://nlp.stanford.edu/IR-book/html/htmledition/naive-bayes-text-classification-1.html">Naive Bayes text classification</a></p>
  </li>
</ul>

<h3 id="section-6">更新记录</h3>

<p>2017年7月15日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shadowsocks设置推荐]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2017/06/14/shadowsocks-setup/"/>
    <updated>2017-06-14T23:49:13+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2017/06/14/shadowsocks-setup</id>
    <content type="html"><![CDATA[<h2 id="shadowsocks">1. Shadowsocks客户端</h2>

<p>Shadowsocks在主流平台上都有<a href="https://shadowsocks.org/en/download/clients.html">客户端</a>，下载直接使用即可。对于Linux平台，可能还需要在Chrome浏览器中安装<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=en">SwitchyOmega</a>插件。</p>

<!--more-->

<h2 id="section">2. 谷歌设置</h2>

<p>进入<a href="https://encrypted.google.com/preferences?hl=zh-CN#languages">网址</a>，设置自己喜欢的语言，之后重启即可。</p>

<h2 id="shadowsocks-1">3. 自己配置Shadowsocks</h2>

<h3 id="section-1">3.1 软件准备</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c"># apt-get install python-setuptools m2crypto supervisor</span>
</span><span class="line"><span class="c"># apt-get install python-pip</span>
</span><span class="line"><span class="c"># pip install --upgrade pip</span>
</span><span class="line"><span class="c"># pip install --upgrade shadowsocks</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">3.2 配置文件</h3>

<p>文件位置<code>/etc/shadowsocks.json</code>，设置模板：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">{
</span><span class="line">    "server":"***.***.***.***",
</span><span class="line">    "local_address": "127.0.0.1",
</span><span class="line">    "port_password":{
</span><span class="line">     "8381":"******",
</span><span class="line">     "8382":"******"
</span><span class="line">    },
</span><span class="line">    "local_port":1080,
</span><span class="line">    "timeout":600,
</span><span class="line">    "method":"aes-256-cfb"
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-3">3.3 启动</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c"># ssserver -c /etc/shadowsocks.json -d start</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="tcp-bbr">4. 使用TCP BBR加速</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c"># echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span>
</span><span class="line"><span class="c"># echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span>
</span><span class="line">
</span><span class="line"><span class="c"># sysctl -p</span>
</span><span class="line">
</span><span class="line"><span class="c"># sysctl net.ipv4.tcp_available_congestion_control</span>
</span><span class="line"><span class="c"># sysctl net.ipv4.tcp_congestion_control</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-4">5. 全局配置</h2>

<p>配合privoxy完成全局应用，参考<a href="https://www.zfl9.com/ss-local.html">具体设置步骤</a>。</p>

<h3 id="section-5">参考资料</h3>

<ol>
  <li>
    <p><a href="http://nga.178.com/read.php?tid=8798506">更改谷歌语言偏好</a></p>
  </li>
  <li>
    <p><a href="https://dirtysalt.github.io/blogs/boost-shadowsocks-with-tcp-bbr.html">通过TCP BBR为ShadowSocks加速</a></p>
  </li>
</ol>

<h3 id="section-6">更新记录</h3>

<p>2017年10月16日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[探索Java基本类型的二进制表示]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2017/05/16/java-binary/"/>
    <updated>2017-05-16T20:17:46+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2017/05/16/java-binary</id>
    <content type="html"><![CDATA[<h2 id="section">1. 基本数据类型</h2>

<p>Java有<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.2">八种</a>基本数据类型（primitive data type），分别是<code>boolean</code>、<code>char</code>、<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>和<code>double</code>，所占用的比特数如下表所示。</p>

<!--more-->

<table>
  <thead>
    <tr>
      <th>Data type</th>
      <th>Bit</th>
      <th>Range</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>boolean</code></td>
      <td>not precisely defined</td>
      <td><code>True</code> or <code>false</code></td>
    </tr>
    <tr>
      <td><code>char</code></td>
      <td>unsigned 16</td>
      <td>$2^{16}$</td>
    </tr>
    <tr>
      <td><code>byte</code></td>
      <td>signed 8</td>
      <td>$-2^{7}$ ~ $2^7-1$</td>
    </tr>
    <tr>
      <td><code>short</code></td>
      <td>signed 16</td>
      <td>$-2^{15}$ ~ $2^{15}-1$</td>
    </tr>
    <tr>
      <td><code>int</code></td>
      <td>signed 32</td>
      <td>$-2^{31}$ ~ $2^{31}-1$</td>
    </tr>
    <tr>
      <td><code>long</code></td>
      <td>signed 64</td>
      <td>$-2^{63}$ ~ $2^{63}-1$</td>
    </tr>
    <tr>
      <td><code>float</code></td>
      <td>signed 32</td>
      <td>$\pm (1-2^{-24}) * 2^{128}$ 精度$2^{-126}$</td>
    </tr>
    <tr>
      <td><code>double</code></td>
      <td>signed 64</td>
      <td>$\pm (1-2^{-53}) * 2^{1024}$ 精度$2^{-1022}$</td>
    </tr>
  </tbody>
</table>

<h2 id="section-1">2. 整数二进制表示和范围</h2>

<p>以<code>byte</code>类型为例，每个整数占用了8个比特，最左边比特位表示正负（0为正，1为负）。例如，$1$表示为$0000 0001_2$。因此，能表示的最大正整数为$0111 1111_2$，即</p>

<script type="math/tex; mode=display">2^0 + 2^1 + 2^2 + \cdots + 2^6 = 2^7 - 1</script>

<p>由于要满足$-1 + 1 = 0$，所以$-1$表示为$1111 1111_2$，$-2$表示为$1111 1110_2$。类似于正整数，可以得到能表示的最大负整数为$1000 0001_2$，即$-(2^7 - 1)$。</p>

<p>但是，这里出现一个问题：出现了两个0，一个是$+0$（$0000 0000_2$），一个是$-0$（$1000 0000_2$）。因此，规定$1000 0000_2$为最大负整数$-2^7$。</p>

<h2 id="section-2">3. 浮点数二进制表示和范围</h2>

<p>Java使用<a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>标准表示浮点数，其二进制表示分为三个部分：1. 最左边比特位表示正负（0为正，1为负）；2. 指数（<code>float</code>有8个比特位，<code>double</code>有11比特位）；3. 尾数（<code>float</code>有23个比特位，<code>double</code>有52比特位）。同时，由于指数需要区分正负，所以<code>float</code>指数位转为十进制后需要减去$2^7-1$，而<code>double</code>需要减去$2^{10}-1$。</p>

<p>以<code>float</code>为例，最大的二进制表示为$0 11111110 11111111111111111111111_2$：</p>

<ul>
  <li>
    <p>最右比特位是0；</p>
  </li>
  <li>
    <p>指数为$1111 1110_2$，即$127$；</p>
  </li>
  <li>
    <p>尾数全为1，即：</p>
  </li>
</ul>

<script type="math/tex; mode=display">2^0 + 2^{-1} + 2^{-2} + \cdots + 2^{-23} = 2-2^{-23}</script>

<p>该数为$(1-2^{-24}) * 2^{128}$。</p>

<p>同理，最小正数为$0 00000001 00000000000000000000000_2$，即$2^{-126}$。</p>

<p>$0 00000000 00000000000000000000000_2$是$+0$，而$1 00000000 00000000000000000000000_2$是$-0$。</p>

<p>$0 11111111 00000000000000000000000_2$是$\infty$，而$1 11111111 00000000000000000000000_2$是$-\infty$。</p>

<h2 id="n">4. 关于2的n次方的有趣事实</h2>

<table>
  <thead>
    <tr>
      <th>n次方</th>
      <th>十进制</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>4</td>
    </tr>
    <tr>
      <td>3</td>
      <td>8</td>
    </tr>
    <tr>
      <td>4</td>
      <td>16</td>
    </tr>
    <tr>
      <td>5</td>
      <td>32</td>
    </tr>
    <tr>
      <td>6</td>
      <td>64</td>
    </tr>
    <tr>
      <td>7</td>
      <td>128</td>
    </tr>
    <tr>
      <td>8</td>
      <td>256</td>
    </tr>
    <tr>
      <td>9</td>
      <td>512</td>
    </tr>
    <tr>
      <td>10</td>
      <td>1024（千）</td>
    </tr>
    <tr>
      <td>20</td>
      <td>1048576（百万）</td>
    </tr>
    <tr>
      <td>30</td>
      <td>1073741824（十亿）</td>
    </tr>
  </tbody>
</table>

<h3 id="section-3">参考资料</h3>

<ol>
  <li>
    <p><a href="https://docs.oracle.com/javase/specs/index.html">The Java Language Specification, Java SE 8 Edition</a></p>
  </li>
  <li>
    <p><a href="http://introcs.cs.princeton.edu/java/home/">Introduction to Programming in Java</a></p>
  </li>
  <li>
    <p><a href="https://en.wikipedia.org/wiki/Two's_complement">Wiki Two’s complement</a></p>
  </li>
  <li>
    <p><a href="http://cs-fundamentals.com/java-programming/java-primitive-data-types.php">Java Primitive Data Types. Size, Range and Default Value of Basic Data Types</a></p>
  </li>
</ol>

<h3 id="section-4">更新记录</h3>

<p>2017年5月16日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个git的rebase命令应用]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/11/11/git-rebase-examples/"/>
    <updated>2016-11-11T16:24:39+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/11/11/git-rebase-examples</id>
    <content type="html"><![CDATA[<p>介绍两个<code>git rebase</code>的应用场景，一个是合并commits记录，另一个是贡献代码。</p>

<h2 id="commit">1. 合并commit记录</h2>

<p>假定有多条commits，按照离当前时间从近至远依次为：<code>c1</code>、<code>b2</code>、<code>b1</code>和<code>a1</code>。希望合并<code>c1</code>、<code>b2</code>和<code>b1</code>，即只保留<code>c1</code>和<code>a1</code>。操作流程如下：</p>

<!--more-->

<ul>
  <li>打开交互式rebase</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>interactive rebase </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>git rebase -i sha1id-of-a1
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>标记合并commits</li>
</ul>

<p>弹出的文本编辑器初始可能为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pick sha1id-of-c1 c1
</span><span class="line">pick sha1id-of-b2 b2
</span><span class="line">pick sha1id-of-b1 b1
</span><span class="line">...</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>修改为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pick sha1id-of-c1 c1
</span><span class="line">squash sha1id-of-b2 b2
</span><span class="line">squash sha1id-of-b1 b1
</span><span class="line">...</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>记录合并commits</li>
</ul>

<p>在弹出的文本编辑器中标记和注释commits</p>

<ul>
  <li>提交远程</li>
</ul>

<p>由于本地和远程记录不一致，需要强制合并。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>force push </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>git push -f origin mybranch
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">2. 贡献代码</h2>

<ul>
  <li>Fork项目</li>
</ul>

<p>Fork在GitHub对应的项目（famous/project，master分支）至自己账户（my/project），克隆至本地并添加远程地址：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>clone project </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>git clone https://github.com/my/project.git
</span><span class="line"><span class="nv">$ </span>git remote add upstream https://github.com/famous/project.git
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>建立分支并提交修改</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>commit </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>git checkout -b devbranch
</span><span class="line"><span class="nv">$ </span>git commit -a -m <span class="s1">&#39;these commits&#39;</span>
</span><span class="line"><span class="nv">$ </span>git push origin devbranch
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>获取和合并最新远程修改</li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>commit </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>git checkout master
</span><span class="line"><span class="nv">$ </span>git pull upstream master
</span><span class="line"><span class="nv">$ </span>git checkout devbranch
</span><span class="line">
</span><span class="line"><span class="nv">$ </span>git rebase master
</span><span class="line"><span class="c">## compare and merge the latest commits</span>
</span><span class="line"><span class="nv">$ </span>git rebase --continue
</span><span class="line">
</span><span class="line"><span class="c">## force push</span>
</span><span class="line"><span class="nv">$ </span>git push -f origin devbranch
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>发起pull request。</li>
</ul>

<h3 id="section-1">参考资料</h3>

<ol>
  <li>
    <p><a href="http://itspg.logdown.com/posts/1731-git-squash-master-commits">合并分支</a></p>
  </li>
  <li>
    <p><a href="https://segmentfault.com/a/1190000000736629">贡献代码</a></p>
  </li>
</ol>

<h3 id="section-2">更新记录</h3>

<p>2016年11月11日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[命令行使用Google Drive]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/10/21/linux-sync-google-drive/"/>
    <updated>2016-10-21T18:24:31+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/10/21/linux-sync-google-drive</id>
    <content type="html"><![CDATA[<p>本文简单介绍<a href="https://github.com/prasmussen/gdrive">gdrive</a>，它是一个跨多个平台软件，提供命令行操作Google Drive。同类软件还有<a href="https://github.com/odeke-em/drive">drive</a>和<a href="https://www.thefanclub.co.za/overgrive">overGrive</a>（Linux下Google Drive界面客户端）。</p>

<p>基本思路：对每一个上传至Google Drive的文件或文件夹都分配一个Id，所以云端操作需要指定Id。</p>

<p>突出优点：自动同步，比较云端和本地文件后，决定上传、删除或者替换；同步加入版本控制，可以下载和删除不同版本文件。</p>

<!--more-->

<h2 id="section">1. 初始化</h2>

<p><a href="https://github.com/prasmussen/gdrive">下载</a>系统对应版本，执行<code>gdrive about</code>，根据提示设置。</p>

<h2 id="section-1">2. 查找</h2>

<p><a href="https://developers.google.com/drive/v3/web/search-parameters">查找规则</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c"># 查找所有文件夹，不包括垃圾箱，所有者为自己</span>
</span><span class="line"><span class="nv">$ </span>gdrive list --query <span class="s2">&quot;mimeType = &#39;application/vnd.google-apps.folder&#39; and trashed = false and &#39;me&#39; in owners&quot;</span>
</span><span class="line">
</span><span class="line"><span class="c"># 加入上层目录Id</span>
</span><span class="line">gdrive list --query <span class="s2">&quot;mimeType = &#39;application/vnd.google-apps.folder&#39; and trashed = false and &#39;me&#39; in owners and &#39;YUlPWWdLcy1mX2c&#39; in parents&quot;</span>
</span><span class="line">
</span><span class="line"><span class="c"># 查询信息</span>
</span><span class="line">gdrive info YUlPWWdLcy1mX2c
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-2">3. 建立和删除</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c"># 建立文件夹</span>
</span><span class="line"><span class="nv">$ </span>gdrive mkdir newFolder
</span><span class="line">
</span><span class="line"><span class="c"># 建立下一层文件夹，-p指定上层目录Id</span>
</span><span class="line"><span class="nv">$ </span>gdrive mkdir -p M1h4M1dGYUhpSFE newFolder
</span><span class="line">
</span><span class="line"><span class="c"># 删除文件（文件Id，非名称）</span>
</span><span class="line"><span class="nv">$ </span>gdrive delete 0BzTeuubJesi
</span><span class="line">
</span><span class="line"><span class="c"># 删除文件夹（文件Id，非名称）</span>
</span><span class="line"><span class="nv">$ </span>gdrive delete -r 0BzTeuubJesi
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-3">4. 普通上传和下载</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c"># 上传文件至制定文件夹</span>
</span><span class="line"><span class="nv">$ </span>gdrive upload -p M1h4M1dGYUhpSFE myFile
</span><span class="line">
</span><span class="line"><span class="c"># 下载文件</span>
</span><span class="line"><span class="nv">$ </span>gdrive download 0BzTeuubJesi
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-4">5. 同步</h2>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="c"># gdrive sync会标记同步文件，因此不要在同步文件夹中使用gdrive upload或者网页上传文件。未标记文件会被忽略。</span>
</span><span class="line"><span class="c"># 同步列表</span>
</span><span class="line"><span class="nv">$ </span>gdrive sync list
</span><span class="line">
</span><span class="line"><span class="c"># 同步列表内容</span>
</span><span class="line"><span class="nv">$ </span>gdrive sync content VUxydm5iMnM5LWs
</span><span class="line">
</span><span class="line"><span class="c"># 上传</span>
</span><span class="line"><span class="nv">$ </span>gdrive sync upload myLocaldir 0BzTeuubJesi
</span><span class="line">
</span><span class="line"><span class="c"># 下载</span>
</span><span class="line"><span class="nv">$ </span>gdrive sync download 0BzTeuubJesi myLocaldir
</span><span class="line">
</span><span class="line"><span class="c"># 查询所有版本</span>
</span><span class="line">gdrive revision list YUlPWWdLcy1mX2c
</span><span class="line">
</span><span class="line"><span class="c"># 下载某一版本，最后两个Id分别为文件Id和版本Id</span>
</span><span class="line">gdrive revision download YUlPWWdLcy1mX2c Y3JBWEJ5a0gwZndlR3hzWlZubFlUMWFnaHVnPQ
</span><span class="line">
</span><span class="line"><span class="c"># 删除某一版本</span>
</span><span class="line">gdrive revision delete YUlPWWdLcy1mX2c Y3JBWEJ5a0gwZndlR3hzWlZubFlUMWFnaHVnPQ
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-5">更新记录</h3>

<p>2016年10月21日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在Nature Communications上发表文章]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/09/22/how-to-publish-in-nc/"/>
    <updated>2016-09-22T16:25:13+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/09/22/how-to-publish-in-nc</id>
    <content type="html"><![CDATA[<p>我最近看到一个<a href="http://spotidoc.com/doc/159334/how-to-get-published-in-nature-communications">幻灯片</a>，主要讲了在Nature Communications（NC）上发表文章的建议，作者是NC的副主编Nicky Dean。整个幻灯片一种轻松幽默的口吻，讲述了投稿和发表文章过程的各种问题，并提出了针对性建议，值得推荐。以下记录一些关键信息。</p>

<!--more-->

<ol>
  <li>
    <p>投稿前注意事项</p>

    <blockquote>
      <ul>
        <li>
          <p><em>Nature</em>杂志（可能此处也指NC）只考虑有重大创新（conceptually novel）的工作，而不是补充完善数据类型研究。</p>
        </li>
        <li>
          <p>不要有快速发表的想法。</p>
        </li>
        <li>
          <p>不介意会议报告或者预印服务网站发表。</p>
        </li>
        <li>
          <p>介意发表在出版的会议录（conference proceedings）或者其他大规模传播的媒介上。</p>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>准备充分</p>

    <blockquote>
      <ul>
        <li>
          <p>问问自己这个研究适合于本领域的哪些地方？这个研究是否有显著的进步？</p>
        </li>
        <li>
          <p>从一开始就好好准备文稿，比如文稿有清晰的结构、容易理解，并且能够传达出最主要信息。</p>
        </li>
        <li>
          <p>阅读《作者须知》，使得文稿符合杂志的要求。</p>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>准备cover letters</p>

    <blockquote>
      <ul>
        <li>
          <p>解释工作的创新，但不要过了。</p>
        </li>
        <li>
          <p>推荐审稿人，但不能都是自己的熟人。</p>
        </li>
        <li>
          <p>可以推荐需要屏蔽的审稿人。</p>
        </li>
        <li>
          <p>明确一切相关的正在发表或者已经投稿的文章。</p>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>文章要素</p>

    <blockquote>
      <ul>
        <li>
          <p>解释清楚研究领域背景，即回答“我们为什么要重视这项研究？”</p>
        </li>
        <li>
          <p>清晰地描述做了什么工作。</p>
        </li>
        <li>
          <p>连接研究内容和领域背景，以说服别人这项研究确实有重大突破。</p>
        </li>
        <li>
          <p>发表文章的目的是为了更有效地交流，而不是显示自己有聪明!</p>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>NC编辑审核常规要点</p>

    <blockquote>
      <ul>
        <li>
          <p>研究的创新性。</p>
        </li>
        <li>
          <p>支持数据。</p>
        </li>
        <li>
          <p>作者或者他人之前的研究。</p>
        </li>
        <li>
          <p>参考文献是否完成，是否重大遗漏。</p>
        </li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p>应对审稿人意见</p>

    <blockquote>
      <ul>
        <li>
          <p>如果被邀请重新提交文章，确保文章解决了<strong>所有</strong>审稿人提出的问题。</p>
        </li>
        <li>
          <p>如果被要求进一步实验，不要尝试规避。</p>
        </li>
        <li>
          <p>保持专业，不要使用侮辱性语言、自大或者恐吓。</p>
        </li>
        <li>
          <p>审稿人也可能会犯错，并且记住他们是自己同行专家。不管怎样，以后大家还是要一起打交道。</p>
        </li>
      </ul>
    </blockquote>
  </li>
</ol>

<h3 id="section">更新记录</h3>

<p>2016年9月22日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HISAT2使用问答]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/09/10/hisat2-faq/"/>
    <updated>2016-09-10T16:32:47+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/09/10/hisat2-faq</id>
    <content type="html"><![CDATA[<p><a href="https://ccb.jhu.edu/software/hisat2/manual.shtml#the-hisat2-build-indexer">HISAT2</a>是一款用于“对应（map）”二代测序数据（全基因组、转录组和外显子组）至目标基因组的工具，用来替代<a href="http://ccb.jhu.edu/software/hisat/index.shtml">HISAT</a>和<a href="http://www.ccb.jhu.edu/software/tophat/index.shtml">TopHat2</a>。本文汇集一些使用HISAT2的常见问题问答。</p>

<h2 id="hisat2">1. 如何解读HISAT2的输出统计？</h2>

<p>一个常见的双端测序样本HISAT2输出统计：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">10000 reads; of these:
</span><span class="line">  10000 (100.00%) were paired; of these:
</span><span class="line">    650 (6.50%) aligned concordantly 0 times
</span><span class="line">    8823 (88.23%) aligned concordantly exactly 1 time
</span><span class="line">    527 (5.27%) aligned concordantly &gt;1 times
</span><span class="line">    ----
</span><span class="line">    650 pairs aligned concordantly 0 times; of these:
</span><span class="line">      34 (5.23%) aligned discordantly 1 time
</span><span class="line">    ----
</span><span class="line">    616 pairs aligned 0 times concordantly or discordantly; of these:
</span><span class="line">      1232 mates make up the pairs; of these:
</span><span class="line">        660 (53.57%) aligned 0 times
</span><span class="line">        571 (46.35%) aligned exactly 1 time
</span><span class="line">        1 (0.08%) aligned &gt;1 times
</span><span class="line">96.70% overall alignment rate</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>总共10000对reads；</p>
  </li>
  <li>
    <p>8823对concordant pairs（一对既方向匹配又有合适距离的reads）有1次精确比对；527对concordant pairs有1次以上比对；34对disconcordant pairs;</p>
  </li>
  <li>
    <p>616对不是concordant pairs，也不是disconcordant pairs中，571个reads有1次精确比对；1个read有1次以上比对；660个reads没有比对成功。</p>
  </li>
  <li>
    <p>因此，整体比对率为1 - (660 / 2) / 10000</p>
  </li>
</ul>

<h2 id="hisat2-1">2. 使用HISAT2前，是否需要对原始数据进行清洗？</h2>

<p>需要。</p>

<h3 id="section">更新记录</h3>

<p>2016年9月10日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用参考基因组下载地址]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/09/10/reference-genome-location/"/>
    <updated>2016-09-10T13:17:00+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/09/10/reference-genome-location</id>
    <content type="html"><![CDATA[<p>本文收集了一些常用参考基因组的下载网址。</p>

<ol>
  <li>
    <p><a href="https://www.ncbi.nlm.nih.gov/genome/">NCBI genome</a></p>
  </li>
  <li>
    <p><a href="http://uswest.ensembl.org/info/data/ftp/index.html">Ensembl FTP</a></p>
  </li>
  <li>
    <p><a href="http://hgdownload.cse.ucsc.edu/goldenPath/">UCSC FTP</a></p>
  </li>
  <li>
    <p><a href="http://www.gencodegenes.org/">GENCODE</a>：只有人和大鼠，注释较好。</p>
  </li>
  <li>
    <p><a href="http://support.illumina.com/sequencing/sequencing_software/igenome.html">iGenomes</a>：部分模式生物bowtie、bowtie2和BWA索引基因组。</p>
  </li>
</ol>

<!--more-->

<ol>
  <li><a href="https://ccb.jhu.edu/software/hisat2/index.shtml">HISAT2</a>：部分模式生物HISAT2索引基因组。</li>
</ol>

<h3 id="section">更新记录</h3>

<p>2016年9月10日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么不推荐在R语言中随意按照下标操作矩阵]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/07/21/subset-matrix-in-r/"/>
    <updated>2016-07-21T19:35:29+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/07/21/subset-matrix-in-r</id>
    <content type="html"><![CDATA[<p>这篇博文的目的是展示R语言中下标操作矩阵的潜在问题。R语言提供了多种方法提取一个矩阵的单个或者部分元素，不同方法对应的效率在Hadley Wickham的<a href="http://adv-r.had.co.nz/Performance.html#language-performance">Advance R</a>中已有讨论。这些方法中，使用最广泛的是通过下标（行或者列）取值，即操作符<code class="language-R">[</code>。然而，这种方法存在潜在问题，即内存中会拷贝原始对象。</p>

<p>举例：首先建立一个矩阵，之后取这个矩阵除了第一行之外的部分，接下来操作这个部分矩阵。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>manipulate </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="R"><span class="line"><span class="c1">## step1: build matrix</span>
</span><span class="line">n <span class="o">&lt;-</span> <span class="m">8000</span>
</span><span class="line">tmp1 <span class="o">&lt;-</span> <span class="kt">matrix</span><span class="p">(</span>rnorm<span class="p">(</span>n <span class="o">*</span> n<span class="p">),</span> nrow <span class="o">=</span> n<span class="p">,</span> ncol <span class="o">=</span> n<span class="p">)</span>
</span><span class="line"><span class="kp">gc</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="c1">## step2: manipulate a subset of matrix</span>
</span><span class="line"><span class="kp">sink</span><span class="p">(</span><span class="s">&#39;/dev/null&#39;</span><span class="p">)</span>
</span><span class="line"><span class="kp">apply</span><span class="p">(</span>tmp1<span class="p">[</span><span class="m">2</span><span class="o">:</span>n<span class="p">,</span> <span class="p">],</span> <span class="m">1</span><span class="p">,</span> <span class="kr">function</span><span class="p">(</span>x<span class="p">)</span> x<span class="p">[</span><span class="m">1</span><span class="p">])</span>
</span><span class="line"><span class="kp">sink</span><span class="p">()</span>
</span><span class="line">
</span><span class="line"><span class="c1">## step3: garbage collection</span>
</span><span class="line"><span class="kp">gc</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<p>内存使用情况如下：</p>

<p><img src="http://yulongniu.bionutshell.org/images/R_apply_memory.png" title="image" alt="UCSC下载rRNA注释" /></p>

<ul>
  <li>
    <p>标记1内存上升，因为建立了<code class="language-R">tmp1</code>的矩阵；</p>
  </li>
  <li>
    <p>标记2内存再次上升，主要因为使用下标取矩阵操作，<code class="language-R">tmp1[2:n, ]</code>；</p>
  </li>
  <li>
    <p>标记3内存下降，因为手动执行垃圾回收。</p>
  </li>
</ul>

<p>可以明显看到内存中多余的垃圾对象。如果使用<code class="language-R">for</code>循环形式，就可以有效避免内存对象拷贝。虽然，R在内存空间不足时，会自动执行<code class="language-R">gc()</code>。但是，执行程序时，不能全指望自动垃圾回收，毕竟有时回收得并不及时，而新的对象又相继生成。这种情况下，内存空间不足就成为很严重的问题。</p>

<p>R版本3.3.1。</p>

<h3 id="section">更新记录</h3>

<p>2016年7月21日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言指针记录]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/04/17/pointers-in-c/"/>
    <updated>2016-04-17T22:42:25+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/04/17/pointers-in-c</id>
    <content type="html"><![CDATA[<h2 id="c">1. C语言指针基础</h2>

<p>C语言的指针设计是一致和优雅的。C语言中“指针（pointer）”就是<strong>地址</strong>（所以不能用普通整数储存地址），“指针变量（pointer variable）”是存储地址的变量。一个指针变量，<strong>只能</strong>指向一个特定类型的变量，比如整数、浮点数、字符或者指针。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Initiate a pointer </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">int</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* &quot;=&quot; does not mean &quot;assignment&quot;, it just means &quot;initiating&quot; */</span>
</span><span class="line"><span class="cm">/* p is the address of tmp1, *p is equal to the value of tmp1*/</span>
</span><span class="line"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp1</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
</span><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp2</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* p points to tmp1, q points to tmp2, now the value of tmp2 is 1*/</span>
</span><span class="line"><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="cm">/* p and q now both points to tmp1*/</span>
</span><span class="line"><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<h2 id="section">2. 指针运算有且只有三种</h2>

<ul>
  <li>
    <p>指针加一个整数，该表达式值为同类型指针；</p>
  </li>
  <li>
    <p>指针减一个整数，该表达式值为同类型指针；</p>
  </li>
  <li>
    <p>指针与指针相减，该表达式值为整数。</p>
  </li>
</ul>

<hr />
<p>指针与<code>++</code>和<code>--</code>结合的表达式</p>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>*p++</code></td>
      <td>表达式值为p指针指向内容，之后指针自增</td>
    </tr>
    <tr>
      <td><code>(*p)++</code></td>
      <td>表达式值为p指针指向内容，之后指向内容自增</td>
    </tr>
    <tr>
      <td><code>++*p</code></td>
      <td>表达式值为p指针指向内容自增，指针不变</td>
    </tr>
    <tr>
      <td><code>*++p</code></td>
      <td>表达式值为p指针自增后指向内容</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="section-1">3. 指针与数组</h2>

<ul>
  <li>
    <p>C语言只有一维数组，其中元素可以是数（整数或浮点数）、字符和指针（字符串、其他类型数组或者其他类型指针）。</p>
  </li>
  <li>
    <p>数组地址为第一个元素地址。可以使用数组名作为指向数组第一个元素的指针，但数组名<span style="color: red">不能</span>被修改，例如不能被重新赋值。因此，假如<code>a</code>数组，<code>a+i</code>等价与<code>&amp;a[i]</code>，<code>*(a+i)</code>等价与<code>a[i]</code>。</p>
  </li>
  <li>
    <p>对于二维数组<code>a</code>，<code>a</code>表示指向第一行的指针（即指针指向一维数组），<code>a[0]</code>表示指向第一行第一个元素的指针。理解<code>a[0]</code>：<code>a[0]</code>等价与<code>*(a + 0)</code>，表示指针<code>a</code>指向的内容，即第一行数组；同时，一维数组名表示指向第一个元素的指针。</p>
  </li>
  <li>
    <p>“字符串字面量（string literal）”被作为字符数组储存，类型为<code>char *</code>，因此对于字符串变量<code>char s[] = "abc";</code>和<code>char *s = "abc";</code>都合法。但是，<code>int a[] = {1, 2, 3};</code>合法，<s>int *a = {1, 2, 3};</s>非法。</p>
  </li>
</ul>

<hr />

<table>
  <thead>
    <tr>
      <th>数组类型</th>
      <th>初始化声明<sup>1</sup></th>
      <th>函数形参声明的指针形式<sup>2</sup></th>
      <th>第一个元素指针声明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>元素为整数的数组</td>
      <td><code>int a[LEN]</code></td>
      <td><code>int *</code></td>
      <td><code>int *p = &amp;a[0]</code>或<code>int *p = a</code></td>
    </tr>
    <tr>
      <td>元素为整数数组的数组（“二维数组”）</td>
      <td><code>int a[ROWNUM][COLNUM]</code></td>
      <td><code>int (*)[COLNUM]</code></td>
      <td><code>int *p = &amp;a[0]</code>或<code>int (*p)[COLNUM] = a</code>　</td>
    </tr>
    <tr>
      <td>元素为字符的数组（“字符串”）</td>
      <td><code>char a[LEN]</code></td>
      <td><code>char *</code></td>
      <td><code>char *p = &amp;a[0]</code>或<code>char *p = a</code></td>
    </tr>
    <tr>
      <td>元素为字符串指针的数组（“字符串数组”）</td>
      <td><code>char *a[LEN]</code></td>
      <td><code>char **</code>或<code>char *[LEN]</code></td>
      <td><code>char **p = &amp;a[0]</code>或<code>char **p = a</code></td>
    </tr>
    <tr>
      <td>元素为结构、联合或枚举的数组</td>
      <td><code>struct t a[LEN]</code></td>
      <td><code>struct t *</code></td>
      <td><code>struct t *p = &amp;a[0]</code>或<code>struct t *p = a</code></td>
    </tr>
  </tbody>
</table>

<p><sup>1</sup>：初始化声明表示在声明同时初始化的形式，比如<code>int a[3] = {1, 2, 3}</code>、<code>char a[] = 'hello'</code>或者<code>char *a[] = {"hello", "world!"}</code>。</p>

<p><sup>2</sup>：在函数中声明形参时，对应的指针类型。形参可以是完整类型或者元素类型，比如，形参<code>char *a[LEN]</code>是完整类型，形参<code>char **a</code>是元素类型；再比如，形参<code>int a[ROWNUM][COLNUM]</code>是完整类型，形参<code>int (*a)[COLNUM]</code>是元素类型；再比如，形参<code>char a[]</code>是完整类型，形参<code>char *a</code>是元素类型。编译器把数组型的形参视为指针。</p>

<hr />

<h2 id="section-2">4. 指针与函数</h2>

<ul>
  <li>
    <p>C语言传入函数的都是值（数组被当做指针传入），而且形参对应对象的一个副本。</p>

    <ul>
      <li>
        <p>形参为指针，可以改变指向的内容。</p>
      </li>
      <li>
        <p>形参为数组，传入指针（指向第一个元素地址）副本。因此，即便是数组名，也可以修改，即可以把数组名当做一个指针用。也可以使用指针传入部分数组。如下代码合法：</p>
      </li>
    </ul>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="kt">void</span> <span class="nf">TestFun</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line">  <span class="o">++</span><span class="n">a</span><span class="p">;</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-3">5. 注意事项</h2>

<ul>
  <li>
    <p>留意未初始化指针，修改未初始化指针所指向内容是<span style="color: red">危险</span>的。字符指针<span style="color: red">必须</span>初始化，比如指向已有字符变量、字符串字面量或动态分配字符串。</p>
  </li>
  <li>
    <p>已有数组名<span style="color: red">不能被</span>重新赋值，<span style="color: red">不能</span>指向其他地址。</p>
  </li>
  <li>
    <p>函数返回指针时，<span style="color: red">不能</span>返回指向局部自动变量的指针，因为局部变量和对应指针在返回时销毁。可以返回指针形式的形参、指向外部变量的指针、指向声明为<code class="language-c">static</code>的局部变量和指向动态分配内存的指针。如下代码合法：</p>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>return pointer points to malloc </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">Add</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
</span><span class="line">  <span class="n">new</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
</span><span class="line">  <span class="p">...</span>
</span><span class="line">  <span class="k">return</span> <span class="n">new</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-4">补充材料</h3>

<ul>
  <li><a id="pointer_array">Pointers and arrays in C</a></li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Using pointers to operate arrays in c </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define N 5</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintVal</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintString</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">Print2Array</span><span class="p">(</span><span class="kt">int</span> <span class="n">colnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rownum</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)[</span><span class="n">colnum</span><span class="p">]);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">Print2Array2</span><span class="p">(</span><span class="kt">int</span> <span class="n">colnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rownum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">a</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintStringArray</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintStringArray2</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">testVal</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">  <span class="n">PrintVal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">testVal</span><span class="p">);</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="kt">int</span> <span class="n">testArray</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span><span class="line">  <span class="n">PrintArray</span><span class="p">(</span><span class="n">testArray</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="kt">char</span> <span class="n">testString</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;hell&quot;</span><span class="p">;</span>
</span><span class="line">  <span class="n">PrintString</span><span class="p">(</span><span class="n">testString</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="kt">int</span> <span class="n">test2Array</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="n">Print2Array</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">test2Array</span><span class="p">);</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">test2Array2</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">test2Array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">test2Array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">test2Array</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">test2Array</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">test2Array</span><span class="p">[</span><span class="mi">4</span><span class="p">]};</span>
</span><span class="line">  <span class="n">Print2Array2</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">test2Array2</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">testStringArray</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;Hello,&quot;</span><span class="p">,</span> <span class="s">&quot;it&quot;</span><span class="p">,</span> <span class="s">&quot;is&quot;</span><span class="p">,</span> <span class="s">&quot;me&quot;</span><span class="p">,</span> <span class="s">&quot;!&quot;</span><span class="p">};</span>
</span><span class="line">  <span class="n">PrintStringArray</span><span class="p">(</span><span class="n">testStringArray</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span><span class="line">  <span class="n">PrintStringArray2</span><span class="p">(</span><span class="n">testStringArray</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintVal</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintArray</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintString</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">Print2Array</span><span class="p">(</span><span class="kt">int</span> <span class="n">colnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rownum</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)[</span><span class="n">colnum</span><span class="p">])</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">colnum</span><span class="p">];</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">colnum</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">rownum</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">Print2Array2</span><span class="p">(</span><span class="kt">int</span> <span class="n">colnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rownum</span><span class="p">,</span> <span class="kt">int</span> <span class="o">**</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">colnum</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">rownum</span><span class="p">;</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintStringArray</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="nf">PrintStringArray2</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>输出结果为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">  2
</span><span class="line">  2  3  5  0  0
</span><span class="line">hell
</span><span class="line">  1  2  3  4  5
</span><span class="line">  0  0  0  0  0
</span><span class="line">  0  0  0  0  0
</span><span class="line">  0  0  0  0  0
</span><span class="line">  0  0  0  0  0
</span><span class="line">  1  2  3  4  5
</span><span class="line">  0  0  0  0  0
</span><span class="line">  0  0  0  0  0
</span><span class="line">  0  0  0  0  0
</span><span class="line">  0  0  0  0  0
</span><span class="line">Hello,
</span><span class="line">it
</span><span class="line">is
</span><span class="line">me
</span><span class="line">!
</span><span class="line">Hello,
</span><span class="line">it
</span><span class="line">is
</span><span class="line">me
</span><span class="line">!</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-5">参考资料</h3>

<ul>
  <li>KN King: <a href="http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504">C Programming: A Modern Approach, 2nd Edition</a>, 2008.</li>
</ul>

<h3 id="section-6">更新记录</h3>

<p>201６年４月17日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rcpp操作矩阵和向量集锦]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/01/07/rcpp-matrix/"/>
    <updated>2016-01-07T20:50:41+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/01/07/rcpp-matrix</id>
    <content type="html"><![CDATA[<p>收集和记录<span style="color: blue">Rcpp</span>或者<span style="color: blue">RcppArmadillo</span>操作矩阵和向量。</p>

<h2 id="span-stylecolor-bluercppspan">1. <span style="color: blue">Rcpp</span></h2>

<ul>
  <li>可以使用逻辑下标（<code>LogicalVector</code>）对向量和列表<a href="http://gallery.rcpp.org/articles/subsetting/">取值</a>。</li>
</ul>

<h2 id="span-stylecolor-bluercpparmadillospan">2. <span style="color: blue">RcppArmadillo</span></h2>

<p>基本类型是<code>mat</code>、<code>vec</code>（<code>colvec</code>）和<code>rowvec</code>。</p>

<ul>
  <li>
    <p>属性</p>

    <ul>
      <li>对于矩阵，行数：<code>m.n_rows;</code>；列数：<code>m.n_cols;</code>；维度：<code>m.size();</code>或<code>size(m);</code>。对于向量，元素数：<code>v.n_elem;</code>。</li>
    </ul>
  </li>
  <li>
    <p>特殊向量或矩阵</p>

    <ul>
      <li>
        <p>全是0<code>ones&lt;mat&gt;(3, 4);</code>/<code>vec(10, fill::ones);</code>/；全是1<code>zeros&lt;vec&gt;(10);</code>/<code>mat(3, 4, fill::zeros);</code>；全是某个数<code>mat a(4, 5); a.fill(123.4);</code>。</p>
      </li>
      <li>
        <p>连续向量，规定长度<code>linspace&lt;vec&gt;(0, 5, 6);</code>；连续向量，规定间距<code>regspace&lt;vec&gt;(0, 2, 9);</code>。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>取值</p>

    <ul>
      <li>
        <p>对于向量，连续取值：<code>v.subvec(1stIdx, lastIdx);</code>；非连续，可以考虑使用<code>find()</code>函数，比如：<code>v.elem(find(v &gt; 0));</code>。</p>
      </li>
      <li>
        <p>对于矩阵，连续取值：<code>m.col(Idx);</code>/<code>m.row(Idx);</code>/<code>m.cols(Idx);</code>/<code>m.rows(Idx);</code>/<code>m.submat(1stRowIdx, lastRowIdx, 1stColIdx, lastColIdx);</code>；非连续，<code>m.submat(vecRowIdx, vecColIdx);</code>。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Rcpp矩阵转换为RcppArmadillo矩阵，可以避免拷贝矩阵，以提升效率，<code class="language-cpp">mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)</code>。同样道理，可以转化向量。例如：</p>
  </li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>transfer matrix and vector </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="n">arma</span><span class="o">::</span><span class="n">mat</span> <span class="n">TransferMatArma</span><span class="p">(</span><span class="n">Rcpp</span><span class="o">::</span><span class="n">NumericMatrix</span> <span class="n">x</span><span class="p">,</span> <span class="n">Rcpp</span><span class="o">::</span><span class="n">NumericVector</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">mat</span> <span class="n">tx</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">nrow</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">ncol</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
</span><span class="line">    <span class="n">vec</span> <span class="nf">ty</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
</span><span class="line">    <span class="k">return</span> <span class="n">tx</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">Rcpp</span><span class="o">::</span><span class="n">NumericVector</span> <span class="n">TransferMatRcpp</span><span class="p">(</span><span class="n">arma</span><span class="o">::</span><span class="n">mat</span> <span class="n">x</span><span class="p">,</span> <span class="n">arma</span><span class="o">::</span><span class="n">vec</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">NumericMatrix</span> <span class="n">tx</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">n_cols</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span><span class="line">    <span class="n">NumericVector</span> <span class="nf">ty</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">y</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ty</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="c1">// 不要使用as&lt;IntegerVector&gt;(wrap(y))，会有内存泄露。</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>使用<code>.each_col()</code>/<code>.each_row()</code>/<code>.for_each()</code>替代<code>apply()</code></li>
</ul>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>replace apply() </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="n">arma</span><span class="o">::</span><span class="n">mat</span> <span class="n">TestMat</span><span class="p">(</span><span class="n">arma</span><span class="o">::</span><span class="n">mat</span> <span class="n">M</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">
</span><span class="line">  <span class="n">M</span><span class="p">.</span><span class="n">for_each</span><span class="p">([</span><span class="n">a</span><span class="p">](</span><span class="n">mat</span><span class="o">::</span><span class="n">elem_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="nl">val</span> <span class="p">:</span> <span class="n">a</span><span class="p">;</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line">
</span><span class="line">  <span class="n">M</span><span class="p">.</span><span class="n">each_row</span><span class="p">([](</span><span class="n">rowvec</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">r</span> <span class="o">/=</span> <span class="n">r</span><span class="p">.</span><span class="n">max</span><span class="p">();</span>
</span><span class="line">    <span class="p">});</span>
</span><span class="line">
</span><span class="line">  <span class="k">return</span> <span class="n">M</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>使用<code>sum(M, 0);</code>和<code>sum(M, 1);</code>分别替代<code>colSums(M)</code>和<code>rowSums(M)</code>。</li>
</ul>

<h3 id="a-idrefa"><a id="Ref">参考网址</a></h3>

<ul>
  <li>
    <p><a href="http://arma.sourceforge.net/docs.html#adv_constructors_mat">Armadillo矩阵</a></p>
  </li>
  <li>
    <p><a href="https://stackoverflow.com/questions/13038256/subset-of-a-rcpp-matrix-that-matches-a-logical-statement">StackOverflow中矩阵提取</a></p>
  </li>
  <li>
    <p><a href="https://github.com/petewerner/misc/wiki/RcppArmadillo-cheatsheet">RcppArmadillo和R对照表</a></p>
  </li>
  <li>
    <p><a href="https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-quickref.pdf">Rcpp Quick Reference Guide</a></p>
  </li>
  <li>
    <p><a href="http://statr.me/rcpp-note/">Rcpp note</a></p>
  </li>
</ul>

<h3 id="section">更新记录</h3>

<p>2017年1月15日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XML中XPath规则总结]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/10/25/xpath-xml/"/>
    <updated>2015-10-25T19:05:33+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/10/25/xpath-xml</id>
    <content type="html"><![CDATA[<p><a href="http://www.w3.org/TR/xpath-30/">XPath</a>提供了一种对XML节点、节点属性和内容快速查询的规则。在各种编程语言中都有实现，比如C语言的<a href="http://www.xmlsoft.org/">libxml2</a>和对应的R包 <a href="https://cran.r-project.org/web/packages/xml2/index.html">xml2</a>。</p>

<h2 id="section">1. 查询规则</h2>

<p>XPath查询集中在三个对象：节点、节点属性和节点内容。</p>

<h3 id="section-1">1.1 选择节点</h3>

<ul>
  <li>
    <p><code>/nodeA/nodeB</code>：nodeA为根节点，nodeA下的所有nodeB节点；等价于<code>nodeB</code>。</p>
  </li>
  <li>
    <p><code>//nodeB</code>：所有nodeB节点，在R包xml2中（比如函数<code class="language-bash">xml_find_all()</code>），<code>//nodeB</code>搜索范围是整个文档，忽略当前节点；而<code>.//nodeB</code>搜索范围是当前节点之下。</p>
  </li>
</ul>

<!--more-->

<ul>
  <li>
    <p><code>//nodeB[1]</code>：所有nodeB节点的第一个；<code>//nodeB[last()-1]</code>：所有nodeB节点的倒数第二个；<code>nodeA/nodeB[position()&lt;3]</code>:当前nodeA节点，其下所有nodeB子节点的前两个。</p>
  </li>
  <li>
    <p><code>/nodeA/*</code>：nodeA为根节点，nodeA下的所有节点；<code>/*/*/nodeC</code>：所有拥有两个父节点的nodeC节点；<code>//*</code>：所有节点。</p>
  </li>
  <li>
    <p><code>//*[count(nodeD)=3]</code>：含有3个nodeD子节点的节点；<code>//*[count(*)=2]</code>：含有任意2个子节点的节点。</p>
  </li>
  <li>
    <p><code>//*[name()='nodeB']</code>：所有名称为“nodeB”的节点，等价于<code>//nodeB</code>；<code>//*[starts-with(name(),'N')]</code>：所有名称以“N”开头的节点；<code>//*[contains(name(),'N')]</code>：所有名称中含有“N”的节点；<code>//*[string-length(name()) = 3]</code>：所有名称的字符串长度等于3的节点。</p>
  </li>
  <li>
    <p><code>//nodeA | //nodeB</code>：所有nodeA，以及nodeB的节点，多个搜索条件合并，搜索添加没有限制。</p>
  </li>
</ul>

<h3 id="section-2">1.2 选择节点属性</h3>

<ul>
  <li>
    <p><code>//@attr1</code>：所有拥有attr1的<strong>属性</strong>，注意：返回的不是节点，而是类此<code>attr1=text1</code>的属性；<code>//node1/@attr1</code>：所有node1带有的attr1属性；<code>//nodeB[@attr1]</code>：所有拥有“attr1”属性的nodeB节点；<code>//nodeB[@attr1='test1']</code>：所有拥有“attr1”属性为“test1”的nodeB节点；<code>//nodeB[normalize-space(@attr1)='test1']</code>：所有拥有attr1属性为“test1”（属性去除字符串前后空格，内部连续空格替换为一个空格）的nodeB节点。</p>
  </li>
  <li>
    <p><code>//node1[@*]</code>：所有node1带有任意属性的节点；<code>//node1[not(@*)]</code>：所有node1不带属性的节点。</p>
  </li>
  <li>
    <p><code>//node1[TEST1][TEST2]</code>：多个属性形选择可以首位相接，依次判断是否为真。TEST1和TEST2同时为真，返回选择结果。<code>//nodeA[nodeB/@attr1='test1']</code>：选择所有nodeA节点，这些nodeA节点拥有nodeB子节点且属性“attr1”为“test1”。<code>//nodeC[@attr1='test1'][../nodeB/@attr2='test2']</code>：选择所有拥有“attr1”为“test1”的nodeC节点，而且这些nodeC节点有属性“attr2”为“test2”的nodeB父亲节点。</p>
  </li>
</ul>

<h3 id="section-3">1.3 选择节点内容</h3>

<ul>
  <li>
    <p><code>/nodeA/nodeB[nodeC&gt;5]</code>：nodeA为根节点，nodeA下的nodeB节点，而且这些nodeB节点必须有nodeC子节点，并且nodeC子节点内容大于5。</p>
  </li>
  <li>
    <p><code>/nodeA/nodeB[nodeC&gt;5]/nodeD</code>：nodeA为根节点，nodeA下的nodeB节点，而且这些nodeB节点必须有nodeC子节点，并且nodeC子节点内容大于5。</p>
  </li>
  <li>
    <p><code>//nodeC[.=5]</code>：所有nodeC节点，其内容等于5。使用<code>.</code>代替自身。</p>
  </li>
  <li>
    <p><code>//nodeC/node()</code>：选择所有nodeC节点下的所有点，包括节点下内容和子节点（距离最近，不包括子节点的子节点）。</p>
  </li>
  <li>
    <p><code>//nodeC/text()</code>：选择所有nodeC节点下的内容。</p>
  </li>
</ul>

<h3 id="section-4">1.4 函数使用</h3>

<ul>
  <li><code>//nodeC[contains(text(), 'test1')]</code>：选择所有nodeC节点，而且nodeC节点下内容包括“test1”。</li>
</ul>

<h2 id="section-5">2. 轴</h2>

<ul>
  <li>
    <p><code>child::</code>：默认轴，可以省略。比如<code>/child::nodeA</code>等价于<code>/AAA</code>。</p>
  </li>
  <li>
    <p><code>descendant::</code>：选择上下文节点的所有子节点、子节点的子节点、子节点的子节点的子节点（依次类推，直至最后一个子节点）。<code>//nodeA/descendant::*</code>：所有nodeA节点的所有子节点、子节点的子节点等等；<code>//nodeA/descendant::nodeC</code>：所有nodeA节点的所有的nodeC子节点，nodeC可能是nodeA的某个子节点的子节点，区别与<code>//nodeA/nodeD</code>；<code>/descendant::*</code>：文档所有子节点、子节点的子节点等等，等价于<code>//*</code>。</p>
  </li>
  <li>
    <p><code>descendant-or-self::*</code>：选择上下文节点自身及其所有子节点、子节点的子节点（依次类推，直至最后一个子节点）。</p>
  </li>
  <li>
    <p><code>parent::</code>：选择上下文节点的父节点（最靠近的父节点）。<code>//nodeC/parent::*</code>：所有nodeC节点的所有父节点；<code>//nodeC/parent::nodeA[@attr1='test1']</code>：nodeC节点的nodeA父节点，这些nodeA父节点的“attr1”属性等于“test1”。</p>
  </li>
  <li>
    <p><code>ancestor::</code>：选择上下文节点的父节点，父节点的父节点（依次类推，直至最前一个父节点，包括根节点）。<code>//nodeC/ancestor::nodeA</code>：所有nodeC的父节点和父节点的父节点等等中的nodeA节点。</p>
  </li>
  <li>
    <p><code>ancestor-or-self::</code>：：选择上下文节点自身及其所有父节点，父节点的父节点（依次类推，直至最前一个父节点，包括根节点）。</p>
  </li>
  <li>
    <p><code>following-sibling::</code>：选择与上下文节点等级相同（即深度相同）的且位置靠后（上为前，下为后）的兄弟节点。<code>//nodeC/following-sibling::*</code>：所有nodeC节点等级相同的且位置靠后的兄弟节点。</p>
  </li>
  <li>
    <p><code>preceding-sibling::</code>：同<code>following-sibling::</code>，也是兄弟节点但位置靠前。</p>
  </li>
  <li>
    <p><code>following::</code>：选择上下文节点之后的所有节点（包括对应的子节点），但除了根节点。<code>//nodeC/following::*</code>：所有nodeC节点之后的所有节点。</p>
  </li>
  <li>
    <p><code>preceding::</code>：选择上下文节点之前的所有节点（包括对应的子节点），但除了根节点。</p>
  </li>
  <li>
    <p><code>//nodeC/ancestor::* | //nodeC/descendant::* | //nodeC/following::* | //nodeC/preceding::* | //nodeC/self::*</code>：所有节点，等价于<code>//*</code>或者等价于<code>/descendant::*</code>。</p>
  </li>
</ul>

<h2 id="section-6">参考网址</h2>

<ul>
  <li>
    <p><a href="https://zh.wikipedia.org/wiki/XPath">维基百科对XPath介绍</a></p>
  </li>
  <li>
    <p><a href="http://www.zvon.org/xxl/XPathTutorial/General_chi/examples.html">zvon中XPath的有趣例子</a></p>
  </li>
  <li>
    <p><a href="http://www.w3school.com.cn/xpath/index.asp">w3school的XPath中文教程</a></p>
  </li>
  <li>
    <p><a href="http://xccds1977.blogspot.sg/2013/02/xmlxpath.html">博文《XML和XPath使用方法备忘》</a></p>
  </li>
</ul>

<h3 id="section-7">更新记录</h3>

<p>2015年10月24日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spacemacs使用记录]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/09/30/spacemacs-tutorial/"/>
    <updated>2015-09-30T16:31:09+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/09/30/spacemacs-tutorial</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/syl20bnr/spacemacs">Spacemacs</a>结合了Vim和Emacs，而且定制了各种好用的设置，极大地减轻了Emacs的配置负担。推荐使用<code>hybrid</code>模式，这样浏览代码时可以使用Vim快捷键，进入Insert mode后使用Emacs快捷键。<code>hybrid</code>模式还有一个好处，编辑时方便汉字输入。Vim模式的先导键是<code>SPC</code>，在Emacs模式下是<code>M-m</code>。</p>

<!--more-->

<h2 id="vim">1. Vim快捷键记录</h2>

<p>在Spacemacs中<code>SPC-h-T</code>进入Emacs Evil快速入门。</p>

<h3 id="section">1.1 移动</h3>

<ul>
  <li>
    <p><code>h</code>：前</p>
  </li>
  <li>
    <p><code>j</code>：上</p>
  </li>
  <li>
    <p><code>k</code>：下</p>
  </li>
  <li>
    <p><code>l</code>：后</p>
  </li>
  <li>
    <p><code>gg</code>：</p>

    <ul>
      <li>
        <p>文档开始位置。</p>
      </li>
      <li>
        <p><code>G</code>：文档结束位置。</p>
      </li>
      <li>
        <p><code>:[number]</code>：跳转到制定行。</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="section-1">1.2 插入和替换</h3>

<ul>
  <li>
    <p><code>i</code>：</p>

    <ul>
      <li>
        <p>在<strong>光标前</strong>的位置，进入insert mode，进行编辑。</p>
      </li>
      <li>
        <p><code>ESC</code>或者<code>C-[</code>退出insert mode。</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code>r</code>：替换<strong>光标所在位置</strong>的单个字符。</p>
  </li>
  <li>
    <p><code>[number] d object</code>：</p>

    <ul>
      <li>
        <p><code>cw</code>或<code>ce</code>：从光标处删除整个单词，并进入insert mode。</p>
      </li>
      <li>
        <p><code>c$</code>：从光标处删除整行，并进入insert mode。</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="section-2">1.3 搜索和替换</h3>

<ul>
  <li>
    <p><code>\</code>：</p>

    <ul>
      <li>
        <p><code>\searchWord</code>：输入搜索内容，<code>n</code>向下搜索，<code>N</code>向上搜索。</p>
      </li>
      <li>
        <p><code>%</code>：在各种括号跳转。</p>
      </li>
      <li>
        <p><code>:s/old/new</code>：替换第一个匹配；<code>:s/old/new/g</code>：替换当前行匹配；<code>:#,#s/old/new/g</code>：替换行（<code>#</code>为行号）之间匹配；<code>:%s/old/new/g </code>：替换全文匹配。</p>
      </li>
      <li>
        <p><code>:%s/old/new/gc</code>：替换全文匹配，每一个匹配会提示是否匹配（输入<code>y</code>表示执行替换，<code>n</code>表示跳过匹配）。</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="section-3">1.4 删除、剪切和粘贴</h3>

<ul>
  <li>
    <p><code>x</code>：删除<strong>光标所在位置</strong>的单个字符。</p>
  </li>
  <li>
    <p><code>[number] d object</code>：</p>

    <ul>
      <li>
        <p><code>dw</code>：从光标处删除整个单词，包括单词后的空格。</p>
      </li>
      <li>
        <p><code>de</code>：从光标处删除整个单词，不包括空格。</p>
      </li>
      <li>
        <p><code>d$</code>：从光标处删除整行。</p>
      </li>
      <li>
        <p><code>dd</code>：删除光标所在的整行。</p>
      </li>
    </ul>
  </li>
  <li>
    <p><code>p</code>：在<strong>光标后</strong>的位置粘贴剪切（<code>d</code>类和<code>x</code>操作）的内容。</p>
  </li>
</ul>

<h3 id="section-4">1.5 撤销</h3>

<ul>
  <li>
    <p><code>u</code>：撤销</p>
  </li>
  <li>
    <p><code>Ctr-R</code>：反撤销</p>
  </li>
</ul>

<h2 id="section-5">2. 常用快捷键</h2>

<p>常用的快捷键参考使用layer的说明文档。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些共轭先验]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/08/02/conjugate-priors/"/>
    <updated>2015-08-02T15:53:54+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/08/02/conjugate-priors</id>
    <content type="html"><![CDATA[<script type="text/x-mathjax-config">
MathJax.Hub.Config({
TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

<script type="math/tex; mode=display">\newcommand{\md}{\mathrm{d}}</script>

<p><a href="https://en.wikipedia.org/wiki/Conjugate_prior#cite_note-beta_rate-6">共轭先验（Conjugate prior）</a>在贝叶斯估计中被广泛应用，本文尝试详细推理一些常见分布的共轭先验证。</p>

<!--more-->

<p>贝叶斯公式：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
f(\theta | x) &= \frac{f(\theta, x)}{f(x)} \\
&= \frac{f(x | \theta)f(\theta)}{\int f(x | \theta)f(\theta) \md \theta}
\end{split}
\label{eq:1}
\end{align} %]]&gt;</script>

<h2 id="section">1. 离散分布</h2>

<h3 id="section-1">1.1 伯努利分布</h3>

<p>伯努利分布（Bernoulli distribution）的概率质量函数为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
f(k;p) = p^k (1-p)^{1-k} \quad \mathrm{for} \quad k \in \{0, 1\}
\end{split}
\label{eq:2}
\end{align}</script>

<p>对于随机变量$X_i \in \{X_1, X_2, \dots, X_m\}$易得，$p$的极大似然估计（Maximum Likelihood Estimator, MLE）为$\hat{p}=\frac{\sum_{i=1}^{m}k_i}{m}$。</p>

<p>该分布的共轭先验为Beta分布$\mathrm{Beta}(\alpha, \beta)$，即对于随机变量$X_i$：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
f(p|X_i) &= \frac{p^{k_i} (1-p)^{1-k_i} \frac{1}{\mathrm{B}(\alpha, \beta)} p^{\alpha - 1} (1-p)^{\beta -1}}{f(X_i)} \\
&=\frac{\frac{1}{\mathrm{B}(\alpha, \beta)} p^{k_i+\alpha-1}(1-p)^{\beta - k_i}}{\int_0^1 \frac{1}{\mathrm{B}(\alpha, \beta)} p^{k_i+\alpha-1}(1-p)^{\beta - k_i} \md p} \\
&= \frac{p^{k_i+\alpha-1}(1-p)^{\beta - k_i}}{\mathrm{B}(k_i+\alpha, \beta+1 -k_i)} \\
&= \mathrm{Beta}(k_i+\alpha, \beta+1-k_i)
\end{split}
\label{eq:3}
\end{align} %]]&gt;</script>

<p>根据$\eqref{eq:3}$易得，$f(p \vert X_1, X_2, \dots, X_m) = \mathrm{Beta}(\sum_{i=1}^{m}k_i+\alpha, \beta+m-\sum_{i=1}^{m}k_i)$，期望$\hat{p}=\frac{\sum_{i=1}^{m}k_i+\alpha}{m+\alpha+\beta}$。特别，当$\alpha=1$和$\beta=1$时，即共轭先验为$0-1$之间的均匀分布，$\hat{p}=\frac{\sum_{i=1}^{m}k_i+1}{m+2}$。</p>

<h3 id="section-2">1.2 二项分布</h3>

<p>二项分布（binomial distribution）的概率质量函数为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
f(k;n,p) = \binom{n}{k} p^k (1-p)^{n-k}
\end{split}
\label{eq:4}
\end{align}</script>

<p>对于随机变量$X_i \in \{X_1, X_2, \dots, X_m\}$易得，MLE为$\hat{p}=\frac{\sum_{i=1}^{m}k_i}{nm}$。</p>

<p>该分布的共轭先验为Beta分布$\mathrm{Beta}(\alpha, \beta)$。因此，类似于$\eqref{eq:3}$，$f(p \vert X_1, X_2, \dots, X_m) = \mathrm{Beta}(\sum_{i=1}^{m}k_i+\alpha, \beta+nm-\sum_{i=1}^{m}k_i)$，期望$\hat{p}=\frac{\sum_{i=1}^{m}k_i+\alpha}{nm+\alpha+\beta}$。</p>

<h3 id="section-3">1.3 负二项分布</h3>

<p>负二项（negative binomial distribution）的概率质量函数为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
f(k;r,p) = \binom{r+k-1}{k} p^k (1-p)^{r}
\end{split}
\label{eq:5}
\end{align}</script>

<p>对于随机变量$X_i \in \{X_1, X_2, \dots, X_m\}$易得，MLE为$\hat{p}=\frac{\sum_{i=1}^{m}k_i}{mr+\sum_{i=1}^{m}k_i}$。</p>

<p>该分布的共轭先验为Beta分布$\mathrm{Beta}(\alpha, \beta)$。因此，类似于$\eqref{eq:3}$，$f(p \vert X_1, X_2, \dots, X_m) = \mathrm{Beta}(\sum_{i=1}^{m}k_i+\alpha, \beta+mr)$，期望$\hat{p}=\frac{\sum_{i=1}^{m}k_i+\alpha}{mr+\sum_{i=1}^{m}k_i+\alpha+\beta}$。</p>

<h3 id="section-4">1.4 多项分布</h3>

<p>多项二项（multinomial distribution）的概率质量函数为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
f(x_1, x_2,\dots,x_k;n,p_1,p_2,\dots,p_k) = \frac{n!}{x_1!x_2!\dots x_k!}p_1^{x_1}p_2^{x_2}\dots p_k^{x_k} \quad \mathrm{for} \quad \sum_{i=1}^k p_i=1 \quad \sum_{i=1}^k x_i=n
\end{split}
\label{eq:6}
\end{align}</script>

<p>对于随机变量$X_j \in \{X_1, X_2, \dots, X_m\}$易得，MLE为$\hat{p_i}=\frac{\sum_{j=1}^{m}x_{ij}}{\sum_{i=1}^{k}\sum_{j=1}^{m}x_{ij}}$。</p>

<p>该分布的共轭先验为Dirichlet分布$\mathrm{Dir}(\alpha_1,\alpha_2,\dots,\alpha_k)$，即对于随机变量$X_i$：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
f(p_1,p_2,\dots,p_k|X_1) &= \frac{\frac{n!}{x_{11}!x_{21}!\dots x_{k1}!}p_1^{x_{11}}p_2^{x_{21}}\dots p_k^{x_{k1}} \frac{1}{\mathrm{B}(\boldsymbol{\alpha})} p_1^{\alpha_1-1} p_2^{\alpha_2-1} \dots p_k^{\alpha_k-1}}{f(X_i)} \\
&= \frac{p_1^{\alpha_1+x_{11}-1} p_2^{\alpha_2+x_{21}-1} \dots p_k^{\alpha_k+x_{k1}-1}}{\int_0^1 \int_0^{1-p_1} \cdots \int_0^{1-\sum_{i=1}^{k-2} p_i}p_1^{\alpha_1+x_{11}-1} p_2^{\alpha_2+x_{21}-1} \dots (1-\sum_{i=1}^{k-1}p_i)^{\alpha_k+x_{k1}-1} \md p_1 \md p_2 \dots \md p_{k-1}} \\
&=\frac{\mathrm{\Gamma}\left(\sum_{i=1}^{k}(\alpha_i+x_{i1})\right)}{\prod_{i=1}^{k}\mathrm{\Gamma}(\alpha_i+x_{i1})}p_1^{\alpha_1+x_{11}-1} p_2^{\alpha_2+x_{21}-1} \dots p_k^{\alpha_k+x_{k1}-1} \\
&=\mathrm{Dir}(\alpha_1+x_{11},\alpha_2+x_{21},\dots,\alpha_k+x_{k1})
\end{split}
\label{eq:7}
\end{align} %]]&gt;</script>

<p>根据$\eqref{eq:7}$易得，$f(p_1,p_2,\dots,p_k \vert X_1, X_2, \dots, X_m) = \mathrm{Dir}(\alpha_1+\sum_{j=1}^{m}x_{1j},\alpha_2+\sum_{j=1}^{m}x_{2j},\dots,\alpha_k+\sum_{j=1}^{m}x_{kj})$，期望为$\hat{p_i}=\frac{\sum_{j=1}^{m}x_{ij}+\alpha_i}{\sum_{i=1}^{k}\sum_{j=1}^{m}x_{ij} + \sum_{i=1}^{k}\alpha_i}$。特别，当$\alpha_1=\alpha_2=\dots=\alpha_k=1$时，$\hat{p_i}=\frac{\sum_{j=1}^{m}x_{ij}+1}{\sum_{i=1}^{k}\sum_{j=1}^{m}x_{ij}+k}$。</p>

<h3 id="section-5">1.5 泊松分布</h3>

<p>泊松分布（Poisson distribution）的概率质量函数为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
f(k;\lambda) = \frac{\lambda^k \mathrm{e}^{-\lambda}}{k!}
\end{split}
\label{eq:8}
\end{align}</script>

<p>对于随机变量$X_j \in \{X_1, X_2, \dots, X_m\}$易得，MLE为$\hat{\lambda}=\frac{\sum_{i=1}^m k_i}{m}$。</p>

<p>该分布的共轭先验为Gamma分布$\mathrm{Gamma}(\alpha, \beta)$，即对于随机变量$X_i$：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
f(\lambda|X_i) &= \frac{\frac{1}{k_i!}\lambda^{k_i} \mathrm{e}^{-\lambda}\frac{1}{\mathrm{\Gamma}(\alpha)}\beta^\alpha \lambda^{\alpha-1}\mathrm{e}^{-\beta\lambda}}{f(X_i)} \\
&= \frac{\lambda^{k_i+\alpha-1}\mathrm{e}^{-(\beta+1)\lambda}}{\int_0^\infty \lambda^{k_i+\alpha-1}\mathrm{e}^{-(\beta+1)\lambda} \md \lambda} \\
&= \frac{(\beta+1)^{k_i+\alpha} \lambda^{k_i+\alpha-1}\mathrm{e}^{-(\beta+1)\lambda}}{\mathrm{\Gamma}(k_i+\alpha)} \\
&= \mathrm{Gamma}(k_i+\alpha, \beta+1)
\end{split}
\label{eq:9}
\end{align} %]]&gt;</script>

<p>根据$\eqref{eq:9}$易得，$f(\lambda \vert X_1, X_2, \dots, X_m) = \mathrm{Gamma}(\sum_{i=1}^{m}k_i+\alpha, \beta+m)$，期望$\hat{p}=\frac{\sum_{i=1}^{m}k_i+\alpha}{\beta+m}$。</p>

<h2 id="section-6">2. 连续分布</h2>

<h3 id="section-7">2.1 指数分布</h3>

<p>指数分布（exponential distribution）的概率密度函数为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
f(x;\lambda) = \lambda \mathrm{e}^{-\lambda x} \quad \mathrm{for} \quad x\ge0
\end{split}
\label{eq:10}
\end{align}</script>

<p>对于随机变量$X_j \in \{X_1, X_2, \dots, X_m\}$易得，MLE为$\hat{\lambda}=\frac{m}{\sum_{i=1}^m k_i}$。</p>

<p>该分布的共轭先验为Gamma分布$\mathrm{Gamma}(\alpha, \beta)$。因此，类似于$\eqref{eq:9}$，$f(\lambda \vert X_1, X_2, \dots, X_m) = \mathrm{Gamma}(\alpha+m, \beta+\sum_{i=1}^{m}k_i)$，期望$\hat{p}=\frac{\alpha+m}{\beta+\sum_{i=1}^{m}k_i}$</p>

<h3 id="section-8">2.2 已知均值的正态分布</h3>

<p>正态分布的概率密度函数为：</p>

<script type="math/tex; mode=display">\begin{align}
\begin{split}
f(x; \mu, \sigma^2) = \frac{1}{\sqrt{2\pi \sigma^2}} \mathrm{e}^{-\frac{(x-\mu)^2}{2\sigma^2}}
\end{split}
\label{eq:11}
\end{align}</script>

<p>对于随机变量$X_j \in \{X_1, X_2, \dots, X_m\}$易得，MLE为$\hat{\sigma}^2=\frac{\sum_{i=1}^m(x_i-\mu)^2}{m}$。</p>

<p>该分布的共轭先验为inverse Gamma分布$\mathrm{Inv-Gamma}(\alpha, \beta)$，即对于随机变量$X_i$：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align}
\begin{split}
f(\sigma^2|X_i) &= \frac{\frac{1}{\sqrt{2\pi}} \frac{1}{\sigma} \mathrm{e}^{-\frac{(x_i-\mu)^2}{2\sigma^2}} \frac{\beta^\alpha}{\mathrm{\Gamma}(\alpha)} \sigma^{2(-\alpha-1)}\mathrm{e}^{-\frac{\beta}{\sigma^2}}}{f(X_i)} \\
&=\frac{\sigma^{2\left(-\alpha-\frac{3}{2}\right)} e^{\frac{(x_i-\mu)^2+2\beta}{2\sigma^2}}}{\int_0^\infty \sigma^{2\left(-\alpha-\frac{3}{2}\right)} e^{\frac{(x_i-\mu)^2+2\beta}{2\sigma^2}} \md \sigma^2} \\
&= \frac{\left(\beta+\frac{(x_i-\mu)^2}{2}\right)^{\left(-\alpha-\frac{1}{2}\right)}}{\mathrm{\Gamma}\left(\alpha+\frac{1}{2}\right)} \sigma^{2\left(-\alpha-\frac{3}{2}\right)} e^{\frac{(x_i-\mu)^2+2\beta}{2\sigma^2}}\\
&= \mathrm{Inv-Gamma}(\alpha+\frac{1}{2}, \beta+\frac{(x_i-\mu)^2}{2})
\end{split}
\label{eq:12}
\end{align} %]]&gt;</script>

<p>根据$\eqref{eq:12}$易得，$f(\sigma^2 \vert X_1, X_2, \dots, X_m) = \mathrm{Inv-Gamma}(\alpha+\frac{m}{2}, \beta+\frac{\sum_{i=1}^m(x_i-\mu)^2}{2})$，期望$\hat{\sigma}^2=\frac{\beta+\frac{\sum_{i=1}^m(x_i-\mu)^2}{2}}{\alpha+\frac{m}{2}-1}$。</p>

<h2 id="section-9">3. 一些积分证明</h2>

<h3 id="beta">3.1 多元beta函数</h3>

<p>$\int_0^1 \int_0^{1-p_1} \cdots \int_0^{1-\sum_{i=1}^{k-2} p_i}p_1^{\alpha_1-1} p_2^{\alpha_2-1} \dots (1-\sum_{i=1}^{k-1}p_i)^{\alpha_k-1} \md p_1 \md p_2 \dots \md p_{k-1} = \frac{\mathrm{\Gamma}\left(\sum_{i=1}^{k}(\alpha_i)\right)}{\prod_{i=1}^{k}\mathrm{\Gamma}(\alpha_i)} \quad \mathrm{for} \quad \sum_{i=1}^k p_i=1$</p>

<p>令$p_{k-1} = (1-\sum_{i=1}^{k-2}p_i)u$，考察积分：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\begin{split}
\int_0^{1-\sum_{i=1}^{k-2} p_i} p_{k-1}^{\alpha_{k-1}-1} (1-\sum_{i=1}^{k-1}p_i)^{\alpha_k-1} \md p_{k-1} &= \left(1-\sum_{i=1}^{k-2}p_i \right)^{\alpha_{k-1}+\alpha_k-2} \int_0^1 u^{\alpha_{k-1}-1}(1-u)^{\alpha_k-1} \md u \\
&= \left(1-\sum_{i=1}^{k-2}p_i \right)^{\alpha_{k-1}+\alpha_k-2} \frac{\mathrm{\Gamma}(\alpha_{k-1})\mathrm{\Gamma}(\alpha_{k})}{\mathrm{\Gamma}(\alpha_{k-1} + \alpha_{k})}
\end{split}
\end{align*} %]]&gt;</script>

<p>迭代相乘后即得。</p>

<h3 id="gamma">3.2 Gamma积分</h3>

<p>$\int_0^\infty \frac{x^{\alpha-1}}{\mathrm{e}^{\lambda x}} \md x=\frac{\mathrm{\Gamma}(\alpha)}{\lambda^\alpha}$</p>

<p>令$\lambda x=u$：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[
\begin{align*}
\begin{split}
\int_0^\infty \frac{x^{\alpha-1}}{\mathrm{e}^{\lambda x}} \md x &= \lambda^{-\alpha} \int_0^\infty \frac{u^{\alpha-1}}{\mathrm{e}^u} \md u \\
&= \frac{\mathrm{\Gamma}(\alpha)}{\lambda^\alpha}
\end{split}
\end{align*} %]]&gt;</script>

<h3 id="section-10">参考资料</h3>

<ul>
  <li><a href="https://people.eecs.berkeley.edu/~jordan/courses/260-spring10/other-readings/chapter9.pdf">Chapter 9 The exponential family: Conjugate priors</a></li>
</ul>

<h3 id="section-11">更新记录</h3>

<p>2017年11月9日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSQL使用指南]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/07/29/postgresql-usage/"/>
    <updated>2015-07-29T18:24:10+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/07/29/postgresql-usage</id>
    <content type="html"><![CDATA[<h2 id="section">1. 查询</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Query </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="psql"><span class="line"><span class="c1">-- 选取特定的一列或者多列</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 选取全部列</span>
</span><span class="line"><span class="k">SELECT</span> <span class="o">*</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 去除重复，选取一列或多列中唯一元素</span>
</span><span class="line"><span class="c1">-- 如输入多列，则去除多列组合后的重复</span>
</span><span class="line"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 指定输出列数</span>
</span><span class="line"><span class="c1">-- a是输出行数，b是输出起始行（第一行计为0）</span>
</span><span class="line"><span class="k">SELECT</span> <span class="k">column</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">LIMIT</span> <span class="n">a</span> <span class="k">OFFSET</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<ul>
  <li>
    <p>使用<code class="language-bash">;</code>结束一条SQL语句，本文中省略；</p>
  </li>
  <li>
    <p>返回未排序数据；</p>
  </li>
</ul>

<h2 id="section-1">2. 排序</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Ordering </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="psql"><span class="line"><span class="c1">-- 按照一列或者多列升序排序</span>
</span><span class="line"><span class="c1">-- 可以按照“不查询”的列排序</span>
</span><span class="line"><span class="c1">-- 先按照column2排，再按照column5排</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span><span class="p">,</span> <span class="n">column3</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">column2</span><span class="p">,</span> <span class="n">column5</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 降序</span>
</span><span class="line"><span class="c1">-- DESC只作用于最靠近的唯一一列，即column2，不作用于column5</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span><span class="p">,</span> <span class="n">column3</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">column2</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">column5</span>
</span><span class="line">
</span><span class="line"><span class="c1">--使用查询列相对编号</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span><span class="p">,</span> <span class="n">column3</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">ORDER</span> <span class="k">BY</span> <span class="mf">2</span><span class="p">,</span> <span class="n">column5</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>使用相对列查询时，不查询的列，比如上述例子的column5，不能用数字代替。</p>
  </li>
  <li>
    <p>使用相对列查询有风险，不采用。</p>
  </li>
  <li>
    <p>升序关键字为<code class="language-psql">ASC</code>，通常升序为默认。</p>
  </li>
  <li>
    <p><code class="language-psql">ORDER BY</code>必须在制定列和数据集后出现。</p>
  </li>
</ul>

<h2 id="section-2">3. 筛选</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Filter </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="psql"><span class="line"><span class="c1">-- ORDER BY语句需要在WHERE之后</span>
</span><span class="line"><span class="c1">-- AND表示“且”， OR表示“或”，第一个条件满足即终止</span>
</span><span class="line"><span class="c1">-- AND和OR可有任意多个</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="p">(</span><span class="n">column3</span> <span class="o">=</span> <span class="n">a</span> <span class="k">OR</span> <span class="n">column3</span> <span class="o">=</span> <span class="n">b</span><span class="p">)</span> <span class="k">AND</span> <span class="n">column1</span> <span class="o">=</span> <span class="n">c</span>
</span><span class="line"><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">column3</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 多个OR语句使用IN代替，比如上述例子为：</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">column3</span> <span class="k">IN</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">AND</span> <span class="n">column1</span> <span class="o">=</span> <span class="n">c</span>
</span><span class="line"><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">column3</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- NOT与IN连用</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">column3</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- BETWEEN a AND b语句，a必须小于等于b</span>
</span><span class="line"><span class="c1">-- 如a等于b，则相当于筛选与a（或者b）相等数值</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">column1</span> <span class="k">BETWEEN</span> <span class="n">a</span> <span class="k">AND</span> <span class="n">b</span>
</span><span class="line">
</span><span class="line"><span class="c1">--筛选NULL值使用IS NULL</span>
</span><span class="line"><span class="c1">--筛选非NULL值使用IS NOT NULL</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">column1</span> <span class="k">IS</span> <span class="k">NULL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p><a href="http://www.postgresql.org/docs/9.4/static/functions-comparison.html#FUNCTIONS-COMPARISON-TABLE">PostgreSQL支持的比较符</a>：<code class="language-psql">&lt;</code>、<code class="language-psql">&lt;=</code>、<code class="language-psql">&gt;</code>、<code class="language-psql">&gt;=</code>、<code class="language-psql">=</code>和<code class="language-psql">!=</code>（“不等于”也可以表示为<code class="language-psql">&lt;&gt;</code>）。</p>
  </li>
  <li>
    <p>筛选字符串条件，需要对筛选串加引号，比如例子中<code class="language-psql">a</code>为<code class="language-psql">"testStr"</code>。</p>
  </li>
  <li>
    <p>合理使用括号，强制规定<code class="language-psql">AND</code>和<code class="language-psql">OR</code>先后顺序。</p>
  </li>
  <li>
    <p><code class="language-psql">IN</code>语句执行效率高，并且可以嵌套多层<code class="language-psql">SELECT</code>语句（每个<code class="language-psql">SELECT</code>只返回一列数据）。</p>
  </li>
  <li>
    <p>尽量在数据库查询过程，而非自己后续手写，完成数据筛选，因为：1. SQL数据库操作通常比自己手写效率高；2. 便于后续扩展。</p>
  </li>
</ul>

<h2 id="section-3">4. 模式匹配</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Pattern Matching </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="psql"><span class="line"><span class="c1">-- LIKE和NOT LIKE支持对字符串的模式匹配</span>
</span><span class="line"><span class="c1">-- “_”匹配单一一个字符</span>
</span><span class="line"><span class="c1">-- “%”匹配0个或多个字符</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">column1</span> <span class="k">LIKE</span> <span class="s1">&#39;F_y%&#39;</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- SIMILAR TO和NOT SIMILAR TO支持正则匹配</span>
</span><span class="line"><span class="c1">-- 正则匹配中，仍然使用“_”和“%”</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">column1</span> <span class="k">SIMILAR</span> <span class="k">TO</span> <span class="s1">&#39;[^JM]%&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>PostgreSQL支持<code class="language-psql">ILIKE</code>和<code class="language-psql">NOT ILIKE</code>忽略大小写敏感搜索，这不是标准SQL语法。</p>
  </li>
  <li>
    <p>注意数据库自动补充的空格，比如 <code class="language-psql">'F_y'</code>只能匹配“F开头-间隔一个字符-y结尾”的字符串，如果字符串后跟有空格，则不能匹配。</p>
  </li>
  <li>
    <p><a href="http://www.postgresql.org/docs/9.4/static/functions-matching.html">PostgreSQL支持的通配符</a></p>
  </li>
  <li>
    <p>模式匹配效率不高，尽量后置，不要过度使用。</p>
  </li>
</ul>

<h2 id="section-4">5. 函数</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Function </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="psql"><span class="line"><span class="c1">--数学计算</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span> <span class="o">*</span> <span class="n">column3</span> <span class="k">AS</span> <span class="n">newName</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 字符串连接</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">RTRIM</span><span class="p">(</span><span class="n">column1</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39; (&#39;</span> <span class="o">||</span> <span class="n">RTRIM</span><span class="p">(</span><span class="n">column1</span><span class="p">)</span> <span class="o">||</span> <span class="s1">&#39;)&#39;</span> <span class="k">AS</span> <span class="n">newName</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">column1</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 使用函数</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">UPPER</span><span class="p">(</span><span class="n">column2</span><span class="p">)</span> <span class="k">AS</span> <span class="n">newName</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 筛选日期</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">columnDate</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">DATE_PART</span><span class="p">(</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="n">columnDate</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2015</span>
</span><span class="line">
</span><span class="line"><span class="c1">-- 汇总数据</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">AVG</span><span class="p">(</span><span class="k">DISTINCT</span> <span class="n">column1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">newName1</span><span class="p">,</span>
</span><span class="line">       <span class="n">SUM</span><span class="p">(</span><span class="n">column2</span><span class="p">)</span> <span class="k">AS</span> <span class="n">newName2</span><span class="p">,</span>
</span><span class="line">       <span class="n">MAX</span><span class="p">(</span><span class="n">column3</span><span class="p">)</span> <span class="k">AS</span> <span class="n">newName3</span><span class="p">,</span>
</span><span class="line">       <span class="n">MIN</span><span class="p">(</span><span class="n">column4</span><span class="p">)</span> <span class="k">AS</span> <span class="n">newName4</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">Products</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">vend_id</span> <span class="o">=</span> <span class="s1">&#39;DLL01&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p>使用<code class="language-psql">AS</code>及时命名新列。</p>
  </li>
  <li>
    <p>支持数字列的运算有<code class="language-psql">+</code>、<code class="language-psql">-</code>、<code class="language-psql">*</code>和<code class="language-psql">/</code>，更多操作参考<a href="http://www.postgresql.org/docs/9.4/static/functions-math.html">PostgreSQL支持的数值操作</a>。</p>
  </li>
  <li>
    <p>为了移植性考虑，如果使用数据库内置函数，需要对代码相应部分添加详细注释。</p>
  </li>
</ul>

<h2 id="section-5">6. 分组</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>Group </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="psql"><span class="line"><span class="c1">-- 分组的意思是对一列或者多列数据归总</span>
</span><span class="line"><span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span><span class="p">,</span> <span class="n">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">newName</span>
</span><span class="line"><span class="k">FROM</span> <span class="n">dataset</span>
</span><span class="line"><span class="k">WHERE</span> <span class="n">column4</span> <span class="o">&gt;</span> <span class="mf">3</span>
</span><span class="line"><span class="k">GROUP</span> <span class="k">BY</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span>
</span><span class="line"><span class="k">HAVING</span> <span class="n">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1</span>
</span><span class="line"><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">newName</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>
    <p><code class="language-psql">GROUP BY</code>必须出现在<code class="language-psql">WHERE</code>后，<code class="language-psql">ORDER BY</code>前。</p>
  </li>
  <li>
    <p><code class="language-psql">GROUP BY</code>需要配合聚集函数，比如<code class="language-psql">AVE()</code>，一起使用。</p>
  </li>
  <li>
    <p><code class="language-psql">GROUP BY</code>不保证返回结果有特定顺序，如果需要特定顺序，需要指明<code class="language-psql">ORDER BY</code>。<code class="language-psql">ORDER BY</code>可以使用新列名。</p>
  </li>
  <li>
    <p><code class="language-psql">SELECT</code>语句中出现的列，必须在<code class="language-psql">GROUP BY</code>中出现。</p>
  </li>
  <li>
    <p><code class="language-psql">NULL</code>单独给出，多个<code class="language-psql">NULL</code>合并为一组。</p>
  </li>
  <li>
    <p><code class="language-psql">HAVING</code>对分组汇总后数据筛选，区别<code class="language-psql">WHERE</code>（汇总分组前筛选）。不能使用新列名，比如<code class="language-psql">HAVING newName &gt; 1</code>非法。</p>
  </li>
</ul>

<h2 id="postgresql">8. PostgreSQL支持的函数</h2>

<h3 id="section-6">8.1 数值</h3>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-psql">ABS()</code></td>
      <td>绝对值</td>
    </tr>
    <tr>
      <td><code class="language-psql">SQRT()</code></td>
      <td>平方根</td>
    </tr>
    <tr>
      <td><code class="language-psql">ROUND(v numeric, s int)</code></td>
      <td>取特定小数位数</td>
    </tr>
    <tr>
      <td><code class="language-psql">AVG()</code></td>
      <td>平均值，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">MAX()</code></td>
      <td>最大值，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">MIN()</code></td>
      <td>最小指，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">SUM()</code></td>
      <td>求和，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">COUNT(*)</code></td>
      <td>所有行数，包括<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">COUNT(column1)</code></td>
      <td>行数，忽略<code class="language-psql">NULL</code></td>
    </tr>
  </tbody>
</table>

<p>详细参考：<a href="http://www.postgresql.org/docs/9.4/static/functions-math.html">PostgreSQL支持的数值操作</a></p>

<h3 id="section-7">8.2 字符串</h3>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-psql">RTRIM()</code></td>
      <td>删除字符串左侧空格</td>
    </tr>
    <tr>
      <td><code class="language-psql">LTRIM()</code></td>
      <td>删除字符串右侧空格</td>
    </tr>
    <tr>
      <td><code class="language-psql">TRIM()</code></td>
      <td>删除双侧空格</td>
    </tr>
    <tr>
      <td><code class="language-psql">SUBSTRING(string [from int] [for int])</code></td>
      <td>按照索引取字符串（从1开始）</td>
    </tr>
    <tr>
      <td><code class="language-psql">SUBSTRING(string [from int] [for int])</code></td>
      <td>选取符合POSIX正则匹配字符串</td>
    </tr>
    <tr>
      <td><code class="language-psql">CHAR_LENGTH()</code></td>
      <td>计算字符串长度，等同于<code class="language-psql">LENGTH()</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">UPPER()</code></td>
      <td>大写</td>
    </tr>
    <tr>
      <td><code class="language-psql">LOWER()</code></td>
      <td>小写</td>
    </tr>
    <tr>
      <td><code class="language-psql">LEFT(string, n int)</code></td>
      <td>截取左侧n个字符串（从1开始）</td>
    </tr>
  </tbody>
</table>

<p>详细参考：<a href="http://www.postgresql.org/docs/9.4/static/functions-string.html">PostgreSQL支持的字符串操作</a></p>

<h3 id="section-8">8.3 日期</h3>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-psql">CURRENT_DATE</code></td>
      <td>当前日期</td>
    </tr>
    <tr>
      <td><code class="language-psql">DATE_PART(text, timestamp)</code></td>
      <td>选取日期中的年、月或日</td>
    </tr>
  </tbody>
</table>

<p>详细参考：<a href="http://www.postgresql.org/docs/9.4/static/functions-datetime.html">PostgreSQL支持的日期操作</a></p>

<h2 id="section-9">使用建议</h2>

<ol>
  <li>数据集的名字为一个单词，比如<code class="language-psql">priceCustom</code>而不是一个字符串 <code class="language-psql">'price custom'</code>。同样，命名别名（使用<code class="language-psql">AS</code>）也如此。</li>
</ol>

<h3 id="section-10">参考资料</h3>

<ul>
  <li>
    <p>《SQL必知必会（SQL in 10 Minutes, Sams Teach Yourself (4th Edition)）》<a href="https://book.douban.com/subject/24250054/">豆瓣链接</a></p>
  </li>
  <li>
    <p><a href="https://wiki.postgresql.org/wiki/9.1%E7%AC%AC%E5%9B%9B%E7%AB%A0">PostgreSQL Wiki</a></p>
  </li>
</ul>

<h3 id="section-11">更新记录</h3>

<p>2015年7月29日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python使用小技巧]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/07/28/python-tips/"/>
    <updated>2015-07-28T14:37:38+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/07/28/python-tips</id>
    <content type="html"><![CDATA[<p>收集了一些使用Python过程中的小技巧或者常见错误。</p>

<h2 id="while--if--break">1. While–if–break</h2>

<p>适用情况：<strong>当需要执行一个循环，但是不能事先判断何时终止。</strong> 可以在循环内部加入判断，符合要求时跳出。比如，使用程序在某个目录下新建一个文件夹，如果文件名已经存在，需要重新生成文件名；否则，创建文件夹。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>While&#8211;if&#8211;break </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="kn">import</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">os</span>
</span><span class="line">
</span><span class="line"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">    <span class="n">letter</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">97</span><span class="p">,</span> <span class="mi">123</span><span class="p">)]</span>
</span><span class="line">    <span class="n">folderName</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
</span><span class="line">    <span class="n">fn</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folderName</span><span class="p">)</span>
</span><span class="line">    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">True</span><span class="p">:</span>
</span><span class="line">        <span class="c"># get an unique name </span>
</span><span class="line">        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span class="line">        <span class="k">break</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">2. 链式比较操作</h2>

<p>Python支持一个链式的比较操作。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>comparison chain </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">testNum</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class="line">
</span><span class="line"><span class="c"># 链式比较操作</span>
</span><span class="line"><span class="c"># 区别if not和if a is not None</span>
</span><span class="line"><span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">testNum</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">):</span>
</span><span class="line">    <span class="k">print</span><span class="p">(</span><span class="s">&#39;It passed!&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->

<h3 id="section-1">参考网址</h3>

<ul>
  <li>
    <p><a href="https://wiki.python.org/moin/FrontPage">Python Wiki</a></p>
  </li>
  <li>
    <p><a href="http://blog.shenwei.me/python-note/#more-3951">Wei Shen’s Python note</a></p>
  </li>
  <li>
    <p><a href="http://www.codefrom.com/c/214">十个我希望早点知道的python方法</a></p>
  </li>
</ul>

<h3 id="section-2">更新记录</h3>

<p>2015年7月27日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UCSC Table下载注释文件]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/06/02/download-ucsc-gene-mask/"/>
    <updated>2015-06-02T16:49:41+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/06/02/download-ucsc-gene-mask</id>
    <content type="html"><![CDATA[<p>在进行RNA-seq数据分析时，需要从<a href="http://genome.ucsc.edu/cgi-bin/hgTables">UCSC Table</a>下载各种注释信息。比如Cufflinks等要求的转录组注释信息、Cufflinks建议去除的rRNA/tRNA/线粒体组注释。</p>

<h2 id="section">1. 基因注释信息</h2>

<p>下载转录组Ensembl注释文件：</p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_ensembl.png" title="image" alt="UCSC下载Ensembl注释" /></p>

<!--more-->

<p>在“table”选择中，<code class="language-bash">ensemblSource</code>表示Ensembl类型注释，<code class="language-bash">ensemblToGeneName</code>表示Ensembl到基因名注释对应。</p>

<h2 id="rrna">2. rRNA注释信息</h2>

<p>分为两步：</p>

<p>第一步， “table”选择<code class="language-bash">wgEncodeGencodeBasicV19</code>。</p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_rRNA.png" title="image" alt="UCSC下载rRNA注释" /></p>

<p>第二步，按照下图编辑“filter”。</p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_rRNA_maskTable.png" title="image" alt="UCSC下载rRNA注释Table" /></p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_rRNA_mask.png" title="image" alt="UCSC下载rRNA注释筛选" /></p>

<h2 id="trna">3. tRNA注释信息</h2>

<p>分为两步：</p>

<p>第一步，“track”选择 <code class="language-bash">tRNA Genes</code>。</p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_tRNA.png" title="image" alt="UCSC下载tRNA注释" /></p>

<p>第二步，保留pseudo tRNA注释。</p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_tRNA_mask.png" title="image" alt="UCSC下载tRNA注释" /></p>

<h2 id="section-1">4. 线粒体基因组注释</h2>

<p>分为两步：</p>

<p>第一步， “table”选择<code class="language-bash">wgEncodeGencodeBasicV19</code>。</p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_chrM.png" title="image" alt="UCSC下载chrM注释" /></p>

<p>第二步，按照下图编辑“filter”。</p>

<p><img src="http://yulongniu.bionutshell.org/images/hg19_chrM_mask.png" title="image" alt="UCSC下载chrM注释筛选" /></p>

<h3 id="section-2">参考资料</h3>

<ul>
  <li>
    <p>USCS Genome Browser的Google论坛：<a href="https://groups.google.com/a/soe.ucsc.edu/forum/#!topic/genome/IL_aeOuPYU0">1</a>、<a href="https://groups.google.com/a/soe.ucsc.edu/forum/#!msg/genome/jSAY8w1JVVo/P6lk4OJzDNEJ">2</a></p>
  </li>
  <li>
    <p>另一种选择rRNA、tRNA和线粒体组注释的方法<a href="http://onetipperday.blogspot.tw/2012/08/how-to-get-trnarrnamitochondrial-gene.html">How to get tRNA/rRNA/mitochondrial gene GTF file</a></p>
  </li>
  <li>
    <p><a href="http://webappl.blogspot.tw/2015/02/extract-rrna-and-trna-features-from.html">Extract rRNA and tRNA features from UCSC Browser</a></p>
  </li>
</ul>

<h3 id="section-3">更新记录</h3>

<p>2015年6月1日</p>

]]></content>
  </entry>
  
</feed>
