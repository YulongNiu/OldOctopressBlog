<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | 牛牛龙]]></title>
  <link href="http://yulongniu.bionutshell.org/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://yulongniu.bionutshell.org/"/>
  <updated>2018-02-09T14:36:08+08:00</updated>
  <id>http://yulongniu.bionutshell.org/</id>
  <author>
    <name><![CDATA[Yulong Niu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Shadowsocks设置推荐]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2017/06/14/shadowsocks-setup/"/>
    <updated>2017-06-14T23:49:13+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2017/06/14/shadowsocks-setup</id>
    <content type="html"><![CDATA[<h2 id="shadowsocks">1. Shadowsocks客户端</h2>

<p>Shadowsocks在主流平台上都有<a href="https://shadowsocks.org/en/download/clients.html">客户端</a>，下载直接使用即可。对于Linux平台，可能还需要在Chrome浏览器中安装<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=en">SwitchyOmega</a>插件。</p>

<!--more-->

<h2 id="section">2. 谷歌设置</h2>

<p>进入<a href="https://encrypted.google.com/preferences?hl=zh-CN#languages">网址</a>，设置自己喜欢的语言，之后重启即可。</p>

<h2 id="shadowsocks-1">3. 自己配置Shadowsocks</h2>

<h3 id="section-1">3.1 软件准备</h3>

<p>{% codeblock lang:bash %}
# apt-get install python-setuptools m2crypto supervisor
# apt-get install python-pip
# pip install –upgrade pip
# pip install –upgrade shadowsocks
{% endcodeblock %}</p>

<h3 id="section-2">3.2 配置文件</h3>

<p>文件位置<code>/etc/shadowsocks.json</code>，设置模板：</p>

<p>{% raw %}
<code>
{
    "server":"***.***.***.***",
    "local_address": "127.0.0.1",
    "port_password":{
     "8381":"******",
     "8382":"******"
    },
    "local_port":1080,
    "timeout":600,
    "method":"aes-256-cfb"
}
</code>
{% endraw %}</p>

<h3 id="section-3">3.3 启动</h3>

<p>{% codeblock lang:bash %}
# ssserver -c /etc/shadowsocks.json -d start
{% endcodeblock %}</p>

<h2 id="tcp-bbr">4. 使用TCP BBR加速</h2>

<p>{% codeblock lang:bash %}
# echo “net.core.default_qdisc=fq” » /etc/sysctl.conf
# echo “net.ipv4.tcp_congestion_control=bbr” » /etc/sysctl.conf</p>

<h1 id="sysctl--p">sysctl -p</h1>

<h1 id="sysctl-netipv4tcpavailablecongestioncontrol">sysctl net.ipv4.tcp_available_congestion_control</h1>
<p># sysctl net.ipv4.tcp_congestion_control
{% endcodeblock %}</p>

<h2 id="section-4">5. 全局配置</h2>

<p>配合privoxy完成全局应用，参考<a href="https://www.zfl9.com/ss-local.html">具体设置步骤</a>。</p>

<h3 id="section-5">参考资料</h3>

<ol>
  <li>
    <p><a href="http://nga.178.com/read.php?tid=8798506">更改谷歌语言偏好</a></p>
  </li>
  <li>
    <p><a href="https://dirtysalt.github.io/blogs/boost-shadowsocks-with-tcp-bbr.html">通过TCP BBR为ShadowSocks加速</a></p>
  </li>
</ol>

<h3 id="section-6">更新记录</h3>

<p>2017年10月16日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个git的rebase命令应用]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/11/11/git-rebase-examples/"/>
    <updated>2016-11-11T16:24:39+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/11/11/git-rebase-examples</id>
    <content type="html"><![CDATA[<p>介绍两个<code>git rebase</code>的应用场景，一个是合并commits记录，另一个是贡献代码。</p>

<h2 id="commit">1. 合并commit记录</h2>

<p>假定有多条commits，按照离当前时间从近至远依次为：<code>c1</code>、<code>b2</code>、<code>b1</code>和<code>a1</code>。希望合并<code>c1</code>、<code>b2</code>和<code>b1</code>，即只保留<code>c1</code>和<code>a1</code>。操作流程如下：</p>

<!--more-->

<ul>
  <li>打开交互式rebase</li>
</ul>

<p>{% codeblock lang:bash interactive rebase %}
$ git rebase -i sha1id-of-a1
{% endcodeblock %}</p>

<ul>
  <li>标记合并commits</li>
</ul>

<p>弹出的文本编辑器初始可能为：</p>

<p>{% raw %}
<code>
pick sha1id-of-c1 c1
pick sha1id-of-b2 b2
pick sha1id-of-b1 b1
...
</code>
{% endraw %}</p>

<p>修改为：</p>

<p>{% raw %}
<code>
pick sha1id-of-c1 c1
squash sha1id-of-b2 b2
squash sha1id-of-b1 b1
...
</code>
{% endraw %}</p>

<ul>
  <li>记录合并commits</li>
</ul>

<p>在弹出的文本编辑器中标记和注释commits</p>

<ul>
  <li>提交远程</li>
</ul>

<p>由于本地和远程记录不一致，需要强制合并。</p>

<p>{% codeblock lang:bash force push %}
$ git push -f origin mybranch
{% endcodeblock %}</p>

<h2 id="section">2. 贡献代码</h2>

<ul>
  <li>Fork项目</li>
</ul>

<p>Fork在GitHub对应的项目（famous/project，master分支）至自己账户（my/project），克隆至本地并添加远程地址：</p>

<p>{% codeblock lang:bash clone project %}
$ git clone https://github.com/my/project.git
$ git remote add upstream https://github.com/famous/project.git
{% endcodeblock %}</p>

<ul>
  <li>建立分支并提交修改</li>
</ul>

<p>{% codeblock lang:bash commit %}
$ git checkout -b devbranch
$ git commit -a -m ‘these commits’
$ git push origin devbranch
{% endcodeblock %}</p>

<ul>
  <li>获取和合并最新远程修改</li>
</ul>

<p>{% codeblock lang:bash commit %}
$ git checkout master
$ git pull upstream master
$ git checkout devbranch</p>

<p>$ git rebase master
## compare and merge the latest commits
$ git rebase –continue</p>

<h2 id="force-push">force push</h2>
<p>$ git push -f origin devbranch
{% endcodeblock %}</p>

<ul>
  <li>发起pull request。</li>
</ul>

<h3 id="section-1">参考资料</h3>

<ol>
  <li>
    <p><a href="http://itspg.logdown.com/posts/1731-git-squash-master-commits">合并分支</a></p>
  </li>
  <li>
    <p><a href="https://segmentfault.com/a/1190000000736629">贡献代码</a></p>
  </li>
</ol>

<h3 id="section-2">更新记录</h3>

<p>2016年11月11日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[命令行使用Google Drive]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/10/21/linux-sync-google-drive/"/>
    <updated>2016-10-21T18:24:31+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/10/21/linux-sync-google-drive</id>
    <content type="html"><![CDATA[<p>本文简单介绍<a href="https://github.com/prasmussen/gdrive">gdrive</a>，它是一个跨多个平台软件，提供命令行操作Google Drive。同类软件还有<a href="https://github.com/odeke-em/drive">drive</a>和<a href="https://www.thefanclub.co.za/overgrive">overGrive</a>（Linux下Google Drive界面客户端）。</p>

<p>基本思路：对每一个上传至Google Drive的文件或文件夹都分配一个Id，所以云端操作需要指定Id。</p>

<p>突出优点：自动同步，比较云端和本地文件后，决定上传、删除或者替换；同步加入版本控制，可以下载和删除不同版本文件。</p>

<!--more-->

<h2 id="section">1. 初始化</h2>

<p><a href="https://github.com/prasmussen/gdrive">下载</a>系统对应版本，执行<code>gdrive about</code>，根据提示设置。</p>

<h2 id="section-1">2. 查找</h2>

<p><a href="https://developers.google.com/drive/v3/web/search-parameters">查找规则</a></p>

<p>{% codeblock lang:bash %}
# 查找所有文件夹，不包括垃圾箱，所有者为自己
$ gdrive list –query “mimeType = ‘application/vnd.google-apps.folder’ and trashed = false and ‘me’ in owners”</p>

<h1 id="id">加入上层目录Id</h1>
<p>gdrive list –query “mimeType = ‘application/vnd.google-apps.folder’ and trashed = false and ‘me’ in owners and ‘YUlPWWdLcy1mX2c’ in parents”</p>

<h1 id="section-2">查询信息</h1>
<p>gdrive info YUlPWWdLcy1mX2c
{% endcodeblock %}</p>

<h2 id="section-3">3. 建立和删除</h2>

<p>{% codeblock lang:bash %}
# 建立文件夹
$ gdrive mkdir newFolder</p>

<h1 id="pid">建立下一层文件夹，-p指定上层目录Id</h1>
<p>$ gdrive mkdir -p M1h4M1dGYUhpSFE newFolder</p>

<h1 id="id-1">删除文件（文件Id，非名称）</h1>
<p>$ gdrive delete 0BzTeuubJesi</p>

<h1 id="id-2">删除文件夹（文件Id，非名称）</h1>
<p>$ gdrive delete -r 0BzTeuubJesi
{% endcodeblock %}</p>

<h2 id="section-4">4. 普通上传和下载</h2>

<p>{% codeblock lang:bash %}
# 上传文件至制定文件夹
$ gdrive upload -p M1h4M1dGYUhpSFE myFile</p>

<h1 id="section-5">下载文件</h1>
<p>$ gdrive download 0BzTeuubJesi</p>

<p>{% endcodeblock %}</p>

<h2 id="section-6">5. 同步</h2>
<p>{% codeblock lang:bash %}
# gdrive sync会标记同步文件，因此不要在同步文件夹中使用gdrive upload或者网页上传文件。未标记文件会被忽略。
# 同步列表
$ gdrive sync list</p>

<h1 id="section-7">同步列表内容</h1>
<p>$ gdrive sync content VUxydm5iMnM5LWs</p>

<h1 id="section-8">上传</h1>
<p>$ gdrive sync upload myLocaldir 0BzTeuubJesi</p>

<h1 id="section-9">下载</h1>
<p>$ gdrive sync download 0BzTeuubJesi myLocaldir</p>

<h1 id="section-10">查询所有版本</h1>
<p>gdrive revision list YUlPWWdLcy1mX2c</p>

<h1 id="ididid">下载某一版本，最后两个Id分别为文件Id和版本Id</h1>
<p>gdrive revision download YUlPWWdLcy1mX2c Y3JBWEJ5a0gwZndlR3hzWlZubFlUMWFnaHVnPQ</p>

<h1 id="section-11">删除某一版本</h1>
<p>gdrive revision delete YUlPWWdLcy1mX2c Y3JBWEJ5a0gwZndlR3hzWlZubFlUMWFnaHVnPQ
{% endcodeblock %}</p>

<h3 id="section-12">更新记录</h3>

<p>2016年10月21日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostgreSQL使用指南]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/07/29/postgresql-usage/"/>
    <updated>2015-07-29T18:24:10+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/07/29/postgresql-usage</id>
    <content type="html"><![CDATA[<h2 id="section">1. 查询</h2>

<p>{% codeblock lang:psql Query %}
– 选取特定的一列或者多列
SELECT column1, column2
FROM dataset</p>

<p>– 选取全部列
SELECT *
FROM dataset</p>

<p>– 去除重复，选取一列或多列中唯一元素
– 如输入多列，则去除多列组合后的重复
SELECT DISTINCT column1, column2
FROM dataset</p>

<p>– 指定输出列数
– a是输出行数，b是输出起始行（第一行计为0）
SELECT column
FROM dataset
LIMIT a OFFSET b
{% endcodeblock %}</p>

<!--more-->

<ul>
  <li>
    <p>使用<code class="language-bash">;</code>结束一条SQL语句，本文中省略；</p>
  </li>
  <li>
    <p>返回未排序数据；</p>
  </li>
</ul>

<h2 id="section-1">2. 排序</h2>

<p>{% codeblock lang:psql Ordering %}
– 按照一列或者多列升序排序
– 可以按照“不查询”的列排序
– 先按照column2排，再按照column5排
SELECT column1, column2, column3
FROM dataset
ORDER BY column2, column5</p>

<p>– 降序
– DESC只作用于最靠近的唯一一列，即column2，不作用于column5
SELECT column1, column2, column3
FROM dataset
ORDER BY column2 DESC, column5</p>

<p>–使用查询列相对编号
SELECT column1, column2, column3
FROM dataset
ORDER BY 2, column5
{% endcodeblock %}</p>

<ul>
  <li>
    <p>使用相对列查询时，不查询的列，比如上述例子的column5，不能用数字代替。</p>
  </li>
  <li>
    <p>使用相对列查询有风险，不采用。</p>
  </li>
  <li>
    <p>升序关键字为<code class="language-psql">ASC</code>，通常升序为默认。</p>
  </li>
  <li>
    <p><code class="language-psql">ORDER BY</code>必须在制定列和数据集后出现。</p>
  </li>
</ul>

<h2 id="section-2">3. 筛选</h2>

<p>{% codeblock lang:psql Filter %}
– ORDER BY语句需要在WHERE之后
– AND表示“且”， OR表示“或”，第一个条件满足即终止
– AND和OR可有任意多个
SELECT column1, column2
FROM dataset 
WHERE (column3 = a OR column3 = b) AND column1 = c
ORDER BY column3</p>

<p>– 多个OR语句使用IN代替，比如上述例子为：
SELECT column1, column2
FROM dataset 
WHERE column3 IN (a, b) AND column1 = c
ORDER BY column3</p>

<p>– NOT与IN连用
SELECT column1, column2
FROM dataset 
WHERE column3 NOT IN (a, b)</p>

<p>– BETWEEN a AND b语句，a必须小于等于b
– 如a等于b，则相当于筛选与a（或者b）相等数值
SELECT column1, column2
FROM dataset
WHERE column1 BETWEEN a AND b</p>

<p>–筛选NULL值使用IS NULL
–筛选非NULL值使用IS NOT NULL
SELECT column1, column2
FROM dataset
WHERE column1 IS NULL
{% endcodeblock %}</p>

<ul>
  <li>
    <p><a href="http://www.postgresql.org/docs/9.4/static/functions-comparison.html#FUNCTIONS-COMPARISON-TABLE">PostgreSQL支持的比较符</a>：<code class="language-psql">&lt;</code>、<code class="language-psql">&lt;=</code>、<code class="language-psql">&gt;</code>、<code class="language-psql">&gt;=</code>、<code class="language-psql">=</code>和<code class="language-psql">!=</code>（“不等于”也可以表示为<code class="language-psql">&lt;&gt;</code>）。</p>
  </li>
  <li>
    <p>筛选字符串条件，需要对筛选串加引号，比如例子中<code class="language-psql">a</code>为<code class="language-psql">"testStr"</code>。</p>
  </li>
  <li>
    <p>合理使用括号，强制规定<code class="language-psql">AND</code>和<code class="language-psql">OR</code>先后顺序。</p>
  </li>
  <li>
    <p><code class="language-psql">IN</code>语句执行效率高，并且可以嵌套多层<code class="language-psql">SELECT</code>语句（每个<code class="language-psql">SELECT</code>只返回一列数据）。</p>
  </li>
  <li>
    <p>尽量在数据库查询过程，而非自己后续手写，完成数据筛选，因为：1. SQL数据库操作通常比自己手写效率高；2. 便于后续扩展。</p>
  </li>
</ul>

<h2 id="section-3">4. 模式匹配</h2>

<p>{% codeblock lang:psql Pattern Matching %}
– LIKE和NOT LIKE支持对字符串的模式匹配
– “_”匹配单一一个字符
– “%”匹配0个或多个字符
SELECT column1, column2
FROM dataset
WHERE column1 LIKE ‘F_y%’</p>

<p>– SIMILAR TO和NOT SIMILAR TO支持正则匹配
– 正则匹配中，仍然使用“_”和“%”
SELECT column1, column2
FROM dataset
WHERE column1 SIMILAR TO ‘[^JM]%’
{% endcodeblock %}</p>

<ul>
  <li>
    <p>PostgreSQL支持<code class="language-psql">ILIKE</code>和<code class="language-psql">NOT ILIKE</code>忽略大小写敏感搜索，这不是标准SQL语法。</p>
  </li>
  <li>
    <p>注意数据库自动补充的空格，比如 <code class="language-psql">'F_y'</code>只能匹配“F开头-间隔一个字符-y结尾”的字符串，如果字符串后跟有空格，则不能匹配。</p>
  </li>
  <li>
    <p><a href="http://www.postgresql.org/docs/9.4/static/functions-matching.html">PostgreSQL支持的通配符</a></p>
  </li>
  <li>
    <p>模式匹配效率不高，尽量后置，不要过度使用。</p>
  </li>
</ul>

<h2 id="section-4">5. 函数</h2>

<p>{% codeblock lang:psql Function %}
–数学计算
SELECT column1, column2 * column3 AS newName
FROM dataset</p>

<p>– 字符串连接
SELECT RTRIM(column1) || ‘ (‘ || RTRIM(column1) || ‘)’ AS newName
FROM dataset
ORDER BY column1</p>

<p>– 使用函数
SELECT column1, UPPER(column2) AS newName
FROM dataset</p>

<p>– 筛选日期
SELECT column1, columnDate 
FROM dataset
WHERE DATE_PART(‘year’, columnDate) = 2015</p>

<p>– 汇总数据
SELECT AVG(DISTINCT column1) AS newName1,
       SUM(column2) AS newName2,
       MAX(column3) AS newName3,
       MIN(column4) AS newName4
FROM Products 
WHERE vend_id = ‘DLL01’
{% endcodeblock %}</p>

<ul>
  <li>
    <p>使用<code class="language-psql">AS</code>及时命名新列。</p>
  </li>
  <li>
    <p>支持数字列的运算有<code class="language-psql">+</code>、<code class="language-psql">-</code>、<code class="language-psql">*</code>和<code class="language-psql">/</code>，更多操作参考<a href="http://www.postgresql.org/docs/9.4/static/functions-math.html">PostgreSQL支持的数值操作</a>。</p>
  </li>
  <li>
    <p>为了移植性考虑，如果使用数据库内置函数，需要对代码相应部分添加详细注释。</p>
  </li>
</ul>

<h2 id="section-5">6. 分组</h2>

<p>{% codeblock lang:psql Group %}
– 分组的意思是对一列或者多列数据归总
SELECT column1, column2, COUNT(<em>) AS newName 
FROM dataset
WHERE column4 &gt; 3
GROUP BY column1, column2
HAVING COUNT(</em>) &gt; 1
ORDER BY newName
{% endcodeblock %}</p>

<ul>
  <li>
    <p><code class="language-psql">GROUP BY</code>必须出现在<code class="language-psql">WHERE</code>后，<code class="language-psql">ORDER BY</code>前。</p>
  </li>
  <li>
    <p><code class="language-psql">GROUP BY</code>需要配合聚集函数，比如<code class="language-psql">AVE()</code>，一起使用。</p>
  </li>
  <li>
    <p><code class="language-psql">GROUP BY</code>不保证返回结果有特定顺序，如果需要特定顺序，需要指明<code class="language-psql">ORDER BY</code>。<code class="language-psql">ORDER BY</code>可以使用新列名。</p>
  </li>
  <li>
    <p><code class="language-psql">SELECT</code>语句中出现的列，必须在<code class="language-psql">GROUP BY</code>中出现。</p>
  </li>
  <li>
    <p><code class="language-psql">NULL</code>单独给出，多个<code class="language-psql">NULL</code>合并为一组。</p>
  </li>
  <li>
    <p><code class="language-psql">HAVING</code>对分组汇总后数据筛选，区别<code class="language-psql">WHERE</code>（汇总分组前筛选）。不能使用新列名，比如<code class="language-psql">HAVING newName &gt; 1</code>非法。</p>
  </li>
</ul>

<h2 id="postgresql">8. PostgreSQL支持的函数</h2>

<h3 id="section-6">8.1 数值</h3>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-psql">ABS()</code></td>
      <td>绝对值</td>
    </tr>
    <tr>
      <td><code class="language-psql">SQRT()</code></td>
      <td>平方根</td>
    </tr>
    <tr>
      <td><code class="language-psql">ROUND(v numeric, s int)</code></td>
      <td>取特定小数位数</td>
    </tr>
    <tr>
      <td><code class="language-psql">AVG()</code></td>
      <td>平均值，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">MAX()</code></td>
      <td>最大值，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">MIN()</code></td>
      <td>最小指，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">SUM()</code></td>
      <td>求和，忽略<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">COUNT(*)</code></td>
      <td>所有行数，包括<code class="language-psql">NULL</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">COUNT(column1)</code></td>
      <td>行数，忽略<code class="language-psql">NULL</code></td>
    </tr>
  </tbody>
</table>

<p>详细参考：<a href="http://www.postgresql.org/docs/9.4/static/functions-math.html">PostgreSQL支持的数值操作</a></p>

<h3 id="section-7">8.2 字符串</h3>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-psql">RTRIM()</code></td>
      <td>删除字符串左侧空格</td>
    </tr>
    <tr>
      <td><code class="language-psql">LTRIM()</code></td>
      <td>删除字符串右侧空格</td>
    </tr>
    <tr>
      <td><code class="language-psql">TRIM()</code></td>
      <td>删除双侧空格</td>
    </tr>
    <tr>
      <td><code class="language-psql">SUBSTRING(string [from int] [for int])</code></td>
      <td>按照索引取字符串（从1开始）</td>
    </tr>
    <tr>
      <td><code class="language-psql">SUBSTRING(string [from int] [for int])</code></td>
      <td>选取符合POSIX正则匹配字符串</td>
    </tr>
    <tr>
      <td><code class="language-psql">CHAR_LENGTH()</code></td>
      <td>计算字符串长度，等同于<code class="language-psql">LENGTH()</code></td>
    </tr>
    <tr>
      <td><code class="language-psql">UPPER()</code></td>
      <td>大写</td>
    </tr>
    <tr>
      <td><code class="language-psql">LOWER()</code></td>
      <td>小写</td>
    </tr>
    <tr>
      <td><code class="language-psql">LEFT(string, n int)</code></td>
      <td>截取左侧n个字符串（从1开始）</td>
    </tr>
  </tbody>
</table>

<p>详细参考：<a href="http://www.postgresql.org/docs/9.4/static/functions-string.html">PostgreSQL支持的字符串操作</a></p>

<h3 id="section-8">8.3 日期</h3>

<table>
  <thead>
    <tr>
      <th>函数名</th>
      <th>意义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-psql">CURRENT_DATE</code></td>
      <td>当前日期</td>
    </tr>
    <tr>
      <td><code class="language-psql">DATE_PART(text, timestamp)</code></td>
      <td>选取日期中的年、月或日</td>
    </tr>
  </tbody>
</table>

<p>详细参考：<a href="http://www.postgresql.org/docs/9.4/static/functions-datetime.html">PostgreSQL支持的日期操作</a></p>

<h2 id="section-9">使用建议</h2>

<ol>
  <li>数据集的名字为一个单词，比如<code class="language-psql">priceCustom</code>而不是一个字符串 <code class="language-psql">'price custom'</code>。同样，命名别名（使用<code class="language-psql">AS</code>）也如此。</li>
</ol>

<h3 id="section-10">参考资料</h3>

<ul>
  <li>
    <p>《SQL必知必会（SQL in 10 Minutes, Sams Teach Yourself (4th Edition)）》<a href="https://book.douban.com/subject/24250054/">豆瓣链接</a></p>
  </li>
  <li>
    <p><a href="https://wiki.postgresql.org/wiki/9.1%E7%AC%AC%E5%9B%9B%E7%AB%A0">PostgreSQL Wiki</a></p>
  </li>
</ul>

<h3 id="section-11">更新记录</h3>

<p>2015年7月29日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH建立端口转发]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2015/05/31/ssh-tunnel/"/>
    <updated>2015-05-31T21:14:02+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2015/05/31/ssh-tunnel</id>
    <content type="html"><![CDATA[<p>SSH建立端口转发分为两步：</p>

<h2 id="section">1. 连接远程主机</h2>

<p>{% codeblock lang:bash %}
$ ssh -NT -D 8080 usrname@host
{% endcodeblock %}</p>

<!--more-->

<p>其中，<code>-N</code>表示只连接远程主机，不打开远程shell；<code>-T</code>表示不分配TTY；<code>-D</code>表示某端口数据都通过SSH传向远程主机；<code>8080</code>可以设置为其他端口。</p>

<h2 id="chrome">2. 添加Chrome浏览器支持</h2>

<p>添加<a href="https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?hl=en">Proxy SwitchySharp插件</a>，之后在SOCKS host栏目中填入地址<code>127.0.0.1</code>，端口<code>8080</code>并启用即可。</p>

<h3 id="section-1">参考网址</h3>

<ul>
  <li>
    <p><a href="http://www.pchou.info/linux/2015/11/01/ssh-tunnel.html">SSH隧道翻墙的原理和实现</a></p>
  </li>
  <li>
    <p><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">SSH原理与运用（二）：远程操作与端口转发</a></p>
  </li>
</ul>

<h3 id="section-2">更新记录</h3>

<p>2017年5月31日</p>
]]></content>
  </entry>
  
</feed>
