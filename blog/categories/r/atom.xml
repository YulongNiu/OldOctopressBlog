<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: R | 牛牛龙]]></title>
  <link href="http://yulongniu.bionutshell.org/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://yulongniu.bionutshell.org/"/>
  <updated>2018-02-09T01:02:46+08:00</updated>
  <id>http://yulongniu.bionutshell.org/</id>
  <author>
    <name><![CDATA[Yulong Niu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为什么不推荐在R语言中随意按照下标操作矩阵]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/07/21/subset-matrix-in-r/"/>
    <updated>2016-07-21T19:35:29+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/07/21/subset-matrix-in-r</id>
    <content type="html"><![CDATA[<p>这篇博文的目的是展示R语言中下标操作矩阵的潜在问题。R语言提供了多种方法提取一个矩阵的单个或者部分元素，不同方法对应的效率在Hadley Wickham的<a href="http://adv-r.had.co.nz/Performance.html#language-performance">Advance R</a>中已有讨论。这些方法中，使用最广泛的是通过下标（行或者列）取值，即操作符<code class="language-R">[</code>。然而，这种方法存在潜在问题，即内存中会拷贝原始对象。</p>

<p>举例：首先建立一个矩阵，之后取这个矩阵除了第一行之外的部分，接下来操作这个部分矩阵。</p>

<p>{% codeblock lang:R manipulate %}
## step1: build matrix
n &lt;- 8000
tmp1 &lt;- matrix(rnorm(n * n), nrow = n, ncol = n)
gc()</p>

<h2 id="step2-manipulate-a-subset-of-matrix">step2: manipulate a subset of matrix</h2>
<p>sink(‘/dev/null’)
apply(tmp1[2:n, ], 1, function(x) x[1])
sink()</p>

<h2 id="step3-garbage-collection">step3: garbage collection</h2>
<p>gc()
{% endcodeblock %}</p>

<!--more-->

<p>内存使用情况如下：</p>

<p><img src="http://yulongniu.bionutshell.org/images/R_apply_memory.png" title="image" alt="UCSC下载rRNA注释" /></p>

<ul>
  <li>
    <p>标记1内存上升，因为建立了<code class="language-R">tmp1</code>的矩阵；</p>
  </li>
  <li>
    <p>标记2内存再次上升，主要因为使用下标取矩阵操作，<code class="language-R">tmp1[2:n, ]</code>；</p>
  </li>
  <li>
    <p>标记3内存下降，因为手动执行垃圾回收。</p>
  </li>
</ul>

<p>可以明显看到内存中多余的垃圾对象。如果使用<code class="language-R">for</code>循环形式，就可以有效避免内存对象拷贝。虽然，R在内存空间不足时，会自动执行<code class="language-R">gc()</code>。但是，执行程序时，不能全指望自动垃圾回收，毕竟有时回收得并不及时，而新的对象又相继生成。这种情况下，内存空间不足就成为很严重的问题。</p>

<p>R版本3.3.1。</p>

<h3 id="section">更新记录</h3>

<p>2016年7月21日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rcpp操作矩阵和向量集锦]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2016/01/07/rcpp-matrix/"/>
    <updated>2016-01-07T20:50:41+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2016/01/07/rcpp-matrix</id>
    <content type="html"><![CDATA[<p>收集和记录<span style="color: blue">Rcpp</span>或者<span style="color: blue">RcppArmadillo</span>操作矩阵和向量。</p>

<h2 id="span-stylecolor-bluercppspan">1. <span style="color: blue">Rcpp</span></h2>

<ul>
  <li>可以使用逻辑下标（<code>LogicalVector</code>）对向量和列表<a href="http://gallery.rcpp.org/articles/subsetting/">取值</a>。</li>
</ul>

<h2 id="span-stylecolor-bluercpparmadillospan">2. <span style="color: blue">RcppArmadillo</span></h2>

<p>基本类型是<code>mat</code>、<code>vec</code>（<code>colvec</code>）和<code>rowvec</code>。</p>

<ul>
  <li>
    <p>属性</p>

    <ul>
      <li>对于矩阵，行数：<code>m.n_rows;</code>；列数：<code>m.n_cols;</code>；维度：<code>m.size();</code>或<code>size(m);</code>。对于向量，元素数：<code>v.n_elem;</code>。</li>
    </ul>
  </li>
  <li>
    <p>特殊向量或矩阵</p>

    <ul>
      <li>
        <p>全是0<code>ones&lt;mat&gt;(3, 4);</code>/<code>vec(10, fill::ones);</code>/；全是1<code>zeros&lt;vec&gt;(10);</code>/<code>mat(3, 4, fill::zeros);</code>；全是某个数<code>mat a(4, 5); a.fill(123.4);</code>。</p>
      </li>
      <li>
        <p>连续向量，规定长度<code>linspace&lt;vec&gt;(0, 5, 6);</code>；连续向量，规定间距<code>regspace&lt;vec&gt;(0, 2, 9);</code>。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>取值</p>

    <ul>
      <li>
        <p>对于向量，连续取值：<code>v.subvec(1stIdx, lastIdx);</code>；非连续，可以考虑使用<code>find()</code>函数，比如：<code>v.elem(find(v &gt; 0));</code>。</p>
      </li>
      <li>
        <p>对于矩阵，连续取值：<code>m.col(Idx);</code>/<code>m.row(Idx);</code>/<code>m.cols(Idx);</code>/<code>m.rows(Idx);</code>/<code>m.submat(1stRowIdx, lastRowIdx, 1stColIdx, lastColIdx);</code>；非连续，<code>m.submat(vecRowIdx, vecColIdx);</code>。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Rcpp矩阵转换为RcppArmadillo矩阵，可以避免拷贝矩阵，以提升效率，<code class="language-cpp">mat(ptr_aux_mem, n_rows, n_cols, copy_aux_mem = true, strict = false)</code>。同样道理，可以转化向量。例如：</p>
  </li>
</ul>

<p>{% codeblock lang:cpp transfer matrix and vector %}
arma::mat TransferMatArma(Rcpp::NumericMatrix x, Rcpp::NumericVector y) {
    mat tx(x.begin(), x.nrow(), x.ncol(), false);
    vec ty(y.begin(), y.size(), false);
    return tx;
}</p>

<p>Rcpp::NumericVector TransferMatRcpp(arma::mat x, arma::vec y) {
    NumericMatrix tx(x.n_rows, x.n_cols, x.begin());
    NumericVector ty(y.begin(), y.end());
    return ty;</p>

<p>// 不要使用as<IntegerVector>(wrap(y))，会有内存泄露。
}
{% endcodeblock %}</IntegerVector></p>

<ul>
  <li>使用<code>.each_col()</code>/<code>.each_row()</code>/<code>.for_each()</code>替代<code>apply()</code></li>
</ul>

<p>{% codeblock lang:cpp replace apply() %}
arma::mat TestMat(arma::mat M, double a) {</p>

<p>M.for_each(<a href="mat::elem_type&amp; val">a</a> {
      val = val &gt; 0 ? val : a;
    });</p>

<p>M.each_row(<a href="rowvec&amp; r"></a> {
      r /= r.max();
    });</p>

<p>return M;
}
{% endcodeblock %}</p>

<ul>
  <li>使用<code>sum(M, 0);</code>和<code>sum(M, 1);</code>分别替代<code>colSums(M)</code>和<code>rowSums(M)</code>。</li>
</ul>

<h3 id="a-idrefa"><a id="Ref">参考网址</a></h3>

<ul>
  <li>
    <p><a href="http://arma.sourceforge.net/docs.html#adv_constructors_mat">Armadillo矩阵</a></p>
  </li>
  <li>
    <p><a href="https://stackoverflow.com/questions/13038256/subset-of-a-rcpp-matrix-that-matches-a-logical-statement">StackOverflow中矩阵提取</a></p>
  </li>
  <li>
    <p><a href="https://github.com/petewerner/misc/wiki/RcppArmadillo-cheatsheet">RcppArmadillo和R对照表</a></p>
  </li>
  <li>
    <p><a href="https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-quickref.pdf">Rcpp Quick Reference Guide</a></p>
  </li>
  <li>
    <p><a href="http://statr.me/rcpp-note/">Rcpp note</a></p>
  </li>
</ul>

<h3 id="section">更新记录</h3>

<p>2017年1月15日</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R使用parallel包并行计算]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2014/06/25/parallel-package/"/>
    <updated>2014-06-25T10:10:20+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2014/06/25/parallel-package</id>
    <content type="html"><![CDATA[<p>最新版本的R已经内置<span style="color: blue">parallel</span>包，<span style="color: blue">parallel</span>包是从<span style="color: blue"><a href="http://cran.r-project.org/web/packages/snow/index.html">snow</a></span>包和<span style="color: blue"><a href="http://cran.r-project.org/web/packages/multicore/index.html">multicore</a></span>包继承而来，包含了很多非常好用的函数。<span style="color: blue">parallel</span>包可以通过PVM（<span style="color: blue">rpvm</span>包）、MPI（<span style="color: blue"><a href="http://cran.r-project.org/web/packages/Rmpi/index.html">Rmpi</a></span>包）、NetWorkSpaces（<span style="color: blue"><a href="http://cran.r-project.org/web/packages/nws/index.html">nws</a></span>包）和raw sockets（如果以上3种都不能使用）平台进行分布计算，支持cluster和多核个人/服务器计算机。在Linux系统上，通常使用<a href="http://www.open-mpi.org/">openMPI</a>。</p>

<h2 id="span-stylecolor-bluermpispan">1. 安装<span style="color: blue">Rmpi</span>包</h2>

<p>因为使用openMPI，所以<span style="color: blue">parallel</span>包需要<span style="color: blue">Rmpi</span>包来设定节点，所以首先需要在计算机上安装openMPI。</p>

<!--more-->

<h3 id="linuxopenmpi">1.1 Linux系统下安装openMPI环境</h3>

<p>{% codeblock lang:bash %}
# 安装openmpi环境
# yum install openmpi openmpi-devel</p>

<h1 id="section">配置环境（安装时执行，可能之后运行也要执行）</h1>
<p># ldconfig /usr/lib64/openmpi/lib/
{% endcodeblock %}</p>

<p>在<code class="language-bash">~/.bashrc</code>下写入</p>

<p>{% codeblock lang:bash %} 
export LD_LIBRARY_PATH=”${LD_LIBRARY_PATH}${LD_LIBRARY_PATH:+:}/usr/lib64/openmpi/lib/”
{% endcodeblock %}</p>

<p>载入<code class="language-bash">~/.bashrc</code></p>

<p>{% codeblock lang:bash %} 
$ source ~/.bashrc
{% endcodeblock %}</p>

<h3 id="rmpi">1.2 安装Rmpi包</h3>

<p>在启动的R窗口中输入：</p>

<p>{% codeblock lang:r %}
install.packages(“Rmpi”,
                 configure.args =
                 c(“–with-Rmpi-include=/usr/include/openmpi-x86_64/”,
                   “–with-Rmpi-libpath=/usr/lib64/openmpi/lib/”,
                   “–with-Rmpi-type=OPENMPI”))
{% endcodeblock %}</p>

<h2 id="span-stylecolor-blueparallelspan">2. 使用<span style="color: blue">parallel</span>包</h2>

<h3 id="section-1">2.1 设定节点数</h3>

<p>首先，需要设定cluster的节点（nodes）数目</p>

<p>{% codeblock lang:r %}
cl &lt;- makeCluster(2, type = “MPI”)
{% endcodeblock %}</p>

<p>这里对“节点数”设定做一些解释，如果使用cluster，可以直接设定cluster数据即可；如果是在小型服务器或者个人电脑上使用，最大节点数可以设定为“线程数（processor）-1”。比如一个双核四线程计算机，节点数目最大可以设定为3。这是因为<span style="color: blue">snow</span>包（<span style="color: blue">parallel</span>包的主要依赖包）在设计时，总是要保留一个<strong>“主线程”</strong>来处理和整合数据。</p>

<p>在linux系统下，线程数可以通过 <code class="language-bash">$ nproc</code> 查看。</p>

<h3 id="section-2">2.2 内置函数</h3>

<p>使用<span style="color: blue">parallel</span>包中的内置并行运算函数
比如使用<code class="language-r">parApply()</code>、<code class="language-r">parCapply()</code>、<code class="language-r">parRapply()</code>、<code class="language-r">parLapply()</code>和<code class="language-r">parSapply()</code>（如果返回矩阵，使用
<code class="language-r">cbind()</code>）等函数。其中文档中指出，<code class="language-r">parApply()</code>函数对于<strong>二维矩阵</strong>的每一个单元进行操作，因此要慢一些。如果可能，使用<code class="language-r">parCapply()</code>和<code class="language-r">parRapply()</code>对列和行进行操作，以加快运行速度。</p>

<h3 id="section-3">2.3 回收节点</h3>

<p>{% codeblock lang:r %}
stopCluster(cl)
{% endcodeblock %}</p>

<h3 id="section-4">3. 并行计算的包依赖问题</h3>

<p>在并行计算过程中，不可避免地会用到其他包辅助。这里涉及到<span style="color: blue">snow</span>包的一个设计原理：并行运算多个R进程，只有一个主进程载入完整的依赖包环境。这就意味着其他并行的R进程中也要载入依赖的包环境。</p>

<p>有两个思路，第一个思路是修改<code class="language-bash">Rprofile.site</code>文件，让任意R进程在启动时都载入依赖的包。但是，不推荐这种做法，因为这样会增加R载入的速度；并且如果不同的代码用了不同的依赖包，就要不停地修改<code class="language-bash">Rprofile.site</code>文件。</p>

<p>第二个思路是在新开的R进程中“动态”加载需要的包。所谓<strong>“动态”</strong>，没有什么高深的意思，就是“需要的时候加载即可”。根据需要，可以选择以下两种方法。</p>

<ul>
  <li>第一种方法是在直接在启动的R进程中加载包。</li>
</ul>

<p>这种方法非常直观，推荐。</p>

<p>{% codeblock lang:r %}
# 以下代码摘抄自Parallel R，其中packages
# 是一个要选择加载的package列表，
# 比如c(‘bigmemory’, ‘foreach’, ‘doMC’)
worker.init &lt;- function(packages) {
  for (p in packages) {
    library(p, character.only=TRUE)
  }
  NULL
}
clusterCall(cl, worker.init, c(‘bigmemory’, ‘foreach’, ‘doMC’))
{% endcodeblock %}</p>

<ul>
  <li>第二种方法是在调用函数中加入。</li>
</ul>

<p>这种方法不推荐，因为我们将看到这种方法是“投机”了<span style="color: blue">parallel</span>包的并行<code>apply</code>家族函数。原理是：<span style="color: blue">parallel</span>包中最主要的就是<code>apply</code>家族函数，比如<code class="language-r">parApply(cl = NULL, X, MARGIN, FUN, ...)</code>函数，是<span style="color: blue">base</span>包中<code class="language-r">apply()</code>的并行版本。其中会用到一个<code>FUN</code>函数，我们可以在这个函数中加载包，比如写入<code class="language-r">require('bigmemory')</code>等。这样，并行的R进程就会载入需要的包。举例如下：</p>

<p>{% codeblock lang:r %}
Getft &lt;- function(i, arg1, arg2){
  require(packages)
  …
}</p>

<p>adft &lt;- parSapply(cl, 1:10, Getft, argInput1, argInput2)
{% endcodeblock %}</p>

<h2 id="span-stylecolor-bluebigmemoryspan">4. 与<span style="color: blue">bigmemory</span>包结合</h2>

<p><span style="color: blue">parallel</span>包可以很好地与<span style="color: blue">bigmemory</span>包结合，进而进一步提升R操作大数据的能力。</p>

<p>但是，有一个问题是<code class="language-r">parApply()</code>、<code class="language-r">parCapply()</code>、<code class="language-r">parRapply()</code>函数是不能直接调用<span style="color: blue">bigmemory</span>包的<code>big.memory</code>这种S4对象。当然也可以使用<code>mat[, ]</code>之类语句引用big.matrix对象。但是这会把矩阵全部载入内存，也就失去了<code>big.matrix</code>对象的意义，只有在内存允许的情况下这样操作。</p>

<p>解决办法：</p>

<blockquote>
  <ol>
    <li>
      <p>将<code>big.matrix</code>对象的操作放在一个函数中，函数传入的是<code>big.matrix</code>的<code>description file</code>（描述文件），而不是<code>big.matrix</code>对象本身。</p>
    </li>
    <li>
      <p>把这个函数作为<code class="language-r">parLapply()</code>和<code class="language-r">parSapply()</code>的<code>FUN</code>，达到分布计算，而又不直接引用<code>big.matrix</code>对象的目的。</p>
    </li>
    <li>
      <p>这个思路的前提是：创建的<code>big.matrix</code>对象必须是“<strong>内存共享</strong>”的，否则不能将其分布到不同的节点计算。</p>
    </li>
  </ol>
</blockquote>

<p>举一个例子，完整版本见<a href="#final_version">补充材料：Final version</a>，这个例子中首先创建一个<code class="language-r">Getft()</code>函数，接受<code>adAllRowColDesc</code>和<code>adMatDesc</code>两个变量是<code>big.matrix</code>对象的描述文件。在这个函数中，<code class="language-r">attach.big.matrix()</code>通过描述文件引用<code>big.matrix</code>对象，并完成相关操作。</p>

<p>{% codeblock lang:r %}
Getft &lt;- function(i, adAllRowColDesc, adMatDesc){
  adAllRowColData &lt;- attach.big.matrix(adAllRowColDesc)
  adMatData &lt;- attach.big.matrix(adMatDesc)
  rowIndex &lt;- adAllRowColData[i, 1]
  colIndex &lt;- adAllRowColData[i, 2]
  linkData &lt;- c(rowNames[rowIndex], rowNames[colIndex], adMatData[rowIndex, colIndex])
  return(linkData)
}
{% endcodeblock %}
之后，使用<code class="language-r">parSapply()</code>函数调用<code class="language-r">Getft()</code>函数，使用<code>1:nrow(adAllRowCol)</code>作为“<strong>计数器</strong>”。</p>

<p>{% codeblock lang:r %}
adft &lt;- parSapply(cl, 1:nrow(adAllRowCol), Getft, adAllRowColDescFile, adMatDescFile)
{% endcodeblock %}</p>

<p>如果需要处理的<code>big.matrix</code>对象不大，也可以直接使用<code class="language-r">parSapply()</code>函数，详细参考<a href="#bigmatrix_direct">补充材料：Bigmatrix direct version</a>。</p>

<h2 id="span-stylecolor-blueforeachspan">5. 与<span style="color: blue">foreach</span>包比较</h2>

<p>另外一个支持并行计算的包是<span style="color: blue">foreach</span>包，它天生与<code>big.matrix</code>对象匹配。所以，我也提供了使用<code class="language-r">foreach</code>版本，详细参考<a href="#foreach">补充材料：Foreach version</a>。</p>

<p>通过测试可以发现，在数据量较少时（1000行左右），<code class="language-r">foreach</code><a href="#foreach">版本</a>和<code class="language-r">parSapply()</code><a href="#final_version">版本</a>速度基本持平。但是，数据量增大时（百万行），<code class="language-r">foreach</code><a href="#foreach">版本</a>速度明显减慢。原因是在使用<code class="language-r">foreach</code>并行计算时，计算开始时候需要建立索引。这个过程在循环数变大时，会变得非常缓慢。</p>

<p>因此，我们可以看到，如果使用<span style="color: blue">foreach</span>包，会减少代码量，而且程序逻辑也非常清晰，但是遇到超大循环数，速度明显减慢。同时，如果使用<span style="color: blue">parallel</span>包，那么需要一些“技巧”才能与<code>big.matrix</code>对象有效融合。所以，我们的结论是原生态的R（包括提供的一些包）不适合做并行大数据计算。</p>

<h3 id="a-idrefa"><a id="Ref">参考网址</a></h3>

<ul>
  <li>
    <p><a href="http://cran.r-project.org/web/views/HighPerformanceComputing.html">R task: High-Performance and Parallel Computing with R</a></p>
  </li>
  <li>
    <p><a href="http://www.jstatsoft.org/v31/i01/paper">State of the Art in Parallel Computing with R</a>，这篇文章详细介绍了很多R并行计算的平台</p>
  </li>
  <li>
    <p>Rmpi安装：<a href="http://www.stats.uwo.ca/faculty/yu/Rmpi/">1</a>, <a href="https://www.sharcnet.ca/help/index.php/Using_R_and_MPI">2</a>, <a href="http://www.cybaea.net/Blogs/R-tips-Installing-Rmpi-on-Fedora-Linux.html">3</a></p>
  </li>
  <li>
    <p><a href="http://www.sfu.ca/~sblay/R/snow.html">snow包介绍</a></p>
  </li>
  <li>
    <p><a href="http://www.stat.yale.edu/~mjk56/temp/bigmemory-vignette.pdf">The R Package bigmemory: Supporting Efficient Computation and Concurrent Programming with Large Data Sets.</a></p>
  </li>
  <li>
    <p>书籍<a href="http://shop.oreilly.com/product/0636920021421.do">Parallel R</a></p>
  </li>
</ul>

<h3 id="a-idappendixa"><a id="appendix">补充材料</a></h3>

<ul>
  <li><a id="final_version">Final version</a></li>
</ul>

<p>{% codeblock combine parSapply and big.matrix lang:r %}
adj2ftBig &lt;- function(adMat, adAllRowCol, n = 2){</p>

<p># INPUT: ‘adMat’ should be a bigmatrix. ‘adAllRowCol’ is the row and column combination, also is a bigmatrix</p>

<p>require(bigmemory)
  require(parallel)
  cl &lt;- makeCluster(n, type = “MPI”)</p>

<p>adMatDescFile &lt;- describe(adMat)
  adAllRowColDescFile &lt;- describe(adAllRowCol)</p>

<p>rowNames &lt;- rownames(adMat)
  colNames &lt;- colnames(adMat)</p>

<p>ignore &lt;- clusterEvalQ(cl, {library(bigmemory); NULL})</p>

<p>Getft &lt;- function(i, adAllRowColDesc, adMatDesc){
    adAllRowColData &lt;- attach.big.matrix(adAllRowColDesc)
    adMatData &lt;- attach.big.matrix(adMatDesc)
    rowIndex &lt;- adAllRowColData[i, 1]
    colIndex &lt;- adAllRowColData[i, 2]
    linkData &lt;- c(rowNames[rowIndex], rowNames[colIndex], adMatData[rowIndex, colIndex])
    return(linkData)
  }</p>

<p>adft &lt;- parSapply(cl, 1:nrow(adAllRowCol), Getft, adAllRowColDescFile, adMatDescFile)</p>

<p>stopCluster(cl)</p>

<p>return(adft)
}
{% endcodeblock %}</p>

<ul>
  <li><a id="bigmatrix_direct">Bigmatrix direct version</a></li>
</ul>

<p>{% codeblock directly use the big.matrix lang:r %}
adj2ftBig3 &lt;- function(adMat, adAllRowCol, n = 2){</p>

<p># INPUT: ‘adMat’ is a matrix. ‘adAllRowCol’ is the row and column combination, also a matrix.</p>

<p>library(parallel)
  cl &lt;- makeCluster(n, type = “MPI”)</p>

<p>rowNames &lt;- rownames(adMat)
  colNames &lt;- colnames(adMat)</p>

<p>adft &lt;- parRapply(cl = cl, adAllRowCol, function(x) {
    linkData &lt;- c(rowNames[x[1]], colNames[x[2]], adMat[x[1], x[2]])
    return(linkData)
  })</p>

<p>stopCluster(cl)</p>

<p>return(adft)
}
{% endcodeblock %}</p>

<ul>
  <li><a id="foreach">Foreach version</a></li>
</ul>

<p>{% codeblock apply foreach to big.matrix lang:r %}
adj2ftBig2 &lt;- function(adMat, adAllRowCol, n = 4){</p>

<p># INPUT: ‘adMat’ should be a bigmatrix. ‘adAllRowCol’ is the row and column combination, also a bigmatrix.</p>

<p>library(bigmemory)
  library(foreach)
  library(doMC)
  registerDoMC(n)</p>

<p>rowNames &lt;- rownames(adMat)
  colNames &lt;- colnames(adMat)</p>

<p>adft &lt;- foreach (i = 1:nrow(adAllRowCol), .combine = rbind, .inorder=TRUE) %dopar% {
    print(paste(‘It is running ‘, i, ‘ in total of ‘, nrow(adAllRowCol), ‘.’, sep = ‘’))
    linkData &lt;- c(rowNames[adAllRowCol[i, 1]], colNames[adAllRowCol[i, 2]], adMat[adAllRowCol[i, 1], adAllRowCol[i, 2]])
    return(linkData)
  }</p>

<p>return(adft)
}
{% endcodeblock %}</p>

<h3 id="section-5">更新记录</h3>

<p>2015年12月30日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建R包的最简流程]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2014/03/28/creat-r-package/"/>
    <updated>2014-03-28T02:53:05+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2014/03/28/creat-r-package</id>
    <content type="html"><![CDATA[<p>一个最简单创建R包的流程。</p>

<h2 id="section">1. 载入工具包</h2>

<p>安装并载入<span style="color: blue">devtools</span>包和<span style="color: blue">roxygen2</span>包。<span style="color: blue">devtools</span>包提供了一些包的检查、安装和打包的基本工具。<span style="color: blue">roxygen2</span>包则使得书写R帮助文档变得轻松简单。如果习惯使用Emacs，可以结合<a href="http://ess.r-project.org/">ESS</a>建立R包，可以将R代码和帮助文档有效组合在一起，便于管理。当然，也可以使用<a href="http://www.rstudio.com/">Rstudio</a>。</p>

<p>{% codeblock lang:r %}
library(‘devtools’)
library(‘roxygen2’)
{% endcodeblock %}</p>

<!--more-->

<h2 id="span-stylecolor-bluercppspan">2. <span style="color: blue">Rcpp</span>和相关的包</h2>

<p>如果使用了<span style="color: blue">Rcpp</span>或者相关的包，比如<span style="color: blue">RcppArmadillo</span>，需要格外设置。</p>

<p>首先，执行：</p>

<p>{% codeblock lang:r %}
use_rcpp()
{% endcodeblock %}</p>

<p>之后，在<code class="language-r">DESCRIPTION</code>中添加依赖或者需要链接的包名称，比如：</p>

<p>{% raw %}
<code>
Imports: 
    Rcpp
LinkingTo: 
    Rcpp,
    RcppArmadillo
</code>
{% endraw %}</p>

<p>然后，在包的<code class="language-bash">R/</code>目录下，添加一个文件<code class="language-bash">RcppChk.R</code>（文件名称自定），并写入：</p>

<p>{% codeblock lang:r %}
#’ @useDynLib my-pkg-name
#’ @importFrom Rcpp sourceCpp
NULL
#&gt; NULL 
{% endcodeblock %}</p>

<p>注意，修改<code class="language-bash">my-pkg-name</code>为自己的包名称。</p>

<p>最后，所有cpp代码都写在src文件夹下。</p>

<h2 id="description">3. 创建DESCRIPTION文件模板</h2>

<p>{% codeblock lang:r %}
load_all()
{% endcodeblock %}
其中<code class="language-bash">import</code>栏目，在源代码中使用了哪些包，需要逐步在import项目中添加和修改。</p>

<h2 id="section-1">4. 更新文档和检查包</h2>

<p>{% codeblock lang:r %}
document()
check()
{% endcodeblock %}</p>

<h2 id="section-2">5. 安装包</h2>

<p>{% codeblock lang:r %}
install()
{% endcodeblock %}</p>

<h2 id="targzlanguage-bash">6. 生成<code class="language-bash">.tar.gz</code>压缩文件</h2>

<p>{% codeblock lang:r %}
build()
{% endcodeblock %}</p>

<h3 id="a-idrefa"><a id="Ref">参考网址</a></h3>

<ul>
  <li>
    <p><a href="https://www.youtube.com/watch?v=9PyQlbAEujY">创建R包视频</a></p>
  </li>
  <li>
    <p><a href="http://r-pkgs.had.co.nz/src.html">R package by Hadley Wickham</a></p>
  </li>
  <li>
    <p><a href="http://adv-r.had.co.nz/Rcpp.html">Advanced R by Hadley Wickham</a></p>
  </li>
</ul>

<h3 id="section-3">更新记录</h3>

<p>2016年1月6日</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R Ggplot2 Notes]]></title>
    <link href="http://yulongniu.bionutshell.org/blog/2013/10/02/ggplot2-notes/"/>
    <updated>2013-10-02T14:47:11+08:00</updated>
    <id>http://yulongniu.bionutshell.org/blog/2013/10/02/ggplot2-notes</id>
    <content type="html"><![CDATA[<h1 id="r-package-span-stylecolor-blueggplot2span-notes">R Package <span style="color: blue">ggplot2</span> Notes</h1>

<h2 id="basic-grammar">1. Basic grammar</h2>

<h3 id="plot-types">1.1 Plot types</h3>

<p>The R package <span style="color: blue">ggplot2</span> is a famous plot tool for high quality scientific figures. The <span style="color: blue">ggplot2</span> style figures are widely seen in papers published in high quality journals such as <em>PNAS</em>, <em>Nature</em> and <em>Cell</em>.</p>

<p>The input data should be in <strong>data frame</strong> form, and it is easily to use the function <code class="language-r">as.data.frame()</code>. “<span style="color:red"><strong>+</strong></span>” is used to connect different plot statement. A typical <span style="color: blue">ggplot2</span> plot statement is like:</p>

<!--more-->

<p>{% codeblock lang:r %}
require(‘ggplot2’)
ggplot(data=mpg, mapping=aes(x=cty, y=hwy, colour=factor(year))) +
geom_point() + stat_smooth()
{% endcodeblock %}
<code class="language-r">ggplot()</code>: <strong>data</strong> is a <span style="color:blue">data.frame</span> class object. <strong>mapping</strong> is an <code class="language-r">aes()</code> function to specify the X-axis and Y-axis. When a <code class="language-r">aes()</code> is used, a figure legend will be added. If we do not want the legends appear, use <code class="language-r">show_guide = FALSE</code> in <em>geom_XXX</em> or <em>stat_XXX</em></p>

<p><code class="language-r">geom_point()</code>: is used to plot points with the attributes <strong>x</strong>, <strong>y</strong>, alpha, colour, fill, shape, size.</p>

<p><code class="language-r">geom_line()</code>: is used to plot points with the attributes <strong>x</strong>, <strong>y</strong>, alpha, colour, fill, shape, size.</p>

<p><code class="language-r">geom_bar()</code>: bar plot. <code class="language-r">stat = 'identity'</code> for draw the identical, <code class="language-r">hjust</code> and <code class="language-r">vjust</code> is to adjust the x and y axis distance. <code class="language-r">coord_flip()</code> to reverse X and Y axis. <code class="language-r">position = 'dodge'</code> to set position of two bars, can be set as ‘dodge’, ‘stack’, ‘fill’ and ‘identity’.</p>

<p><code class="language-r">geom_box()</code>: boxplot.</p>

<p><code class="language-r">geom_tile()</code>: fill blocks.</p>

<p>{% codeblock lang:r %}
# example
require(‘ggplot2’)
p &lt;- ggplot(mtcars, aes(factor(cyl), mpg))
# basic plot
p + geom_boxplot()
# add colors to boxes
p + geom_boxplot(aes(fill = factor(cyl)))
# change default colors
p + geom_boxplot(aes(fill = factor(cyl))) + scale_fill_manual(values = c(‘red’, ‘green’, ‘blue’))
{% endcodeblock %}
<code class="language-r">geom_rect(mapping = NULL, data = NULL, stat = "identity", position = "identity", ...)</code>: plot rectangles. 
In <code class="language-r">aes()</code>, <code class="language-r">xmin</code>, <code class="language-r">xmax</code>, <code class="language-r">ymin</code>, and <code class="language-r">ymax</code> are necessary. 
<code class="language-r">inherit.aes = FALSE</code> may be used if new <code class="language-r">data</code> is applied.</p>

<p>{% codeblock lang:r %}
# example
ggplot(mtcars) +
  geom_density(aes(x=disp, group=cyl, fill=cyl), alpha=0.6, adjust=0.75) + 
  geom_rect(data=mtcars[1,], aes(xmin=100, xmax=200, ymin=0,ymax=Inf), fill=”red”, alpha=0.2)
{% endcodeblock %}</p>

<h3 id="statistics">1.2 Statistics</h3>

<p><code class="language-r">geom_smooth()</code>: is used for the add smooth line with the <strong>method</strong> lm, glm, gam, loess and rlm. <code class="language-r">se = TRUE</code> is to display the confident region. The following aesthetics <strong>x</strong>, <strong>y</strong>, alpha, colour, fill, linetype, size, weight could be added.</p>

<p><code class="language-r">stat_boxplot()</code>: plot error lines in boxplot.</p>

<h3 id="add-elements">1.3 Add elements</h3>

<p><code class="language-r">xlab()</code>: change X axis label, set <code>xlab('')</code> to remove the X axis label; <code class="language-r">ylab()</code>: change Y axis label; <code class="language-r">ggtitle()</code>: add figure title; <code class="language-r">scale_y_continuous(limits=c(0, 20))</code> and <code class="language-r">scale_x_continuous(limits=c(0, 20))</code> to adjust range of X and Y axis.</p>

<p><code class="language-r">geom_abline(intercept = 37, slope = -5)</code>: to add line.</p>

<p><code class="language-r">geom_hline</code> and <code class="language-r">geom_vline</code>: to add horizontal and vertical lines.</p>

<p>{% codeblock lang:r %}
# example 
p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
geom_vline(xintercept = 1:5, colour=”green”, linetype = “longdash”)
{% endcodeblock %}</p>

<p>{% codeblock lang:r %}
# ggplot2 line type
d &lt;- data.frame(lt=c(‘blank’, ‘solid’, ‘dashed’, ‘dotted’, ‘dotdash’, ‘longdash’, ‘twodash’, ‘1F’, ‘F1’, ‘4C88C488’, ‘12345678’))
ggplot() +
  scale_x_continuous(name=’’, limits=c(0,1), breaks=NULL) +
  scale_y_discrete(name=’linetype’) +
  scale_linetype_identity() +
  geom_segment(data=d, mapping=aes(x=0, xend=1, y=lt, yend=lt, linetype=lt))
{% endcodeblock %}</p>

<p><code class="language-r">geom_text()</code>: to add text. Set <code>parse = TRUE</code> to use expression and greek letters.</p>

<p><code class="language-r">scale_fill_discrete(..., values)</code>: change labels. <code class="language-r">name</code> to reset label names, <code class="language-r">labels</code> to reset labels.</p>

<p><code class="language-r">scale_shape_manual(..., values)</code>: change the shape of points.</p>

<p><code class="language-r">scale_linetype_manual(..., values)</code>: change the types of lines. line referring <a href="http://www.cookbook-r.com/Graphs/Shapes_and_line_types/">R plot</a>.<code>name</code>, <code>value</code>, <code>labels</code> are used to change value.</p>

<p><code class="language-r">scale_color_manual</code> is used for change the colors. Please refer to <a href="http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/">Useful color palette</a>, <a href="http://blog.ggplot2.org/post/24607351280/choosing-colour-palettes-part-ii-educated-choices">Introduction of ggplot2 colors</a>, and <a href="http://research.stowers-institute.org/efg/R/Color/Chart/">R Color Chart</a> 
. The default ggplot2 colors are generated from the “<em>scales</em>” package, for example the default “hue pallet” could be view as <code class="language-r">show_col(hue_pal(h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1)(9))</code></p>

<p><code class="language-r">scale_fill_manual(..., alues)</code> to change filled colors.</p>

<p><code class="language-r">theme</code> is used for exact control. <code>legend.position='none'</code> to remove the side legend.</p>

<h2 id="save-plot">2. Save plot</h2>

<p>The function <code class="language-r">ggsave()</code> is used to save the screen plot to file. <code class="language-r">print()</code> is also applied like:</p>

<p>{% codeblock lang:r %}
pdf(‘testfile.pdf’)
q &lt;- ggplot()
print(q)
dev.off()
{% endcodeblock %}</p>

<h2 id="other-issues">3. Other issues</h2>

<h3 id="plot-mutiple-ggplot2">3.1 Plot mutiple ggplot2</h3>

<p>Use <span style="color: blue">gridExtra</span> package to plot multiple ggplot2 figures in the one figure.</p>

<p>{% codeblock lang:r %}
# example
require(‘gridExtra’)
# save ggplot object into a list like “plotList”
do.call(grid.arrange, plotList)
{% endcodeblock %}</p>

<h3 id="a-idrefa"><a id="Ref">参考网址</a></h3>

<ul>
  <li><a href="http://directlabels.r-forge.r-project.org/examples.html">Better labels</a></li>
  <li><a href="http://docs.ggplot2.org/current/">ggplot2 doc</a></li>
  <li><a href="http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/#working-with-colors">ggplot2 cheatsheet</a></li>
</ul>

<h3 id="section">更新记录</h3>

<p>2014年8月28日</p>
]]></content>
  </entry>
  
</feed>
