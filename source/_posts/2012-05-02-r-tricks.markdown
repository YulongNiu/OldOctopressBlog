---
layout: post
title: "R小技巧集锦"
date: 2012-05-02 22:17:02 -0400
comments: true
categories: r
---

持续更新R语言编程中的一些小技巧，包括一些易错点。
但是，需要注意的，**一旦需要使用一些非常稀奇古怪的技巧时，可以尝试反思是否是自己数据结构或者算法出了问题。**

## 1. `if`{:.language-r}爱你，`else`{:.language-r}就要和你在一起，又要给你一些距离 ##

{% codeblock lang:r %}
if (con){
  expr
  } else{
  expr2
  }
{% endcodeblock %}

`if...else..`{:.language-r}结构中，`}`{:.language-r}与`else`{:.language-r}必须在同一行。

<!--more-->

简易形式（<span style="color: blue">不推荐</span>）：

{% codeblock lang:r %}
# else不能与expr在同一行
if (con) expr
else expr2
{% endcodeblock %}

建议将所有`if ... else ...`{:.language-r}结构写成第一种形式，如果没有`else`{:.language-r}，用`else {}`{:.language-r}代替。



## 2. `NULL`{:.language-r}是空，`NULL`{:.language-r}是气，`NULL`{:.language-r}在R中就是空气。##

如果表达式（expression）或者函数（function）的值没有定义，那么将返回`NULL`{:.language-r}。在R中，`NULL`{:.language-r}与很多对象合并在一起时，都被忽略掉。比如以下例子：

{% codeblock lang:r %}
# NULL is neglected in vector
> c(1, NA, NULL, FALSE)
[1]  1 NA  0

# also in matrix
> matrix(c(1, NA, NULL, 2), c(2, 2))
     [,1] [,2]
[1,]    1    2
[2,]   NA    1
警告信息：
In matrix(c(1, NA, NULL, 2), c(2, 2)) : 数据长度[3]不是矩阵行数[2]的整倍

# also in list
> tmp <- list(1, 2)
> tmp[1] <- NULL
> tmp
[[1]]
[1] 2
> tmp[[1]] <- NULL
> tmp
list()
{% endcodeblock %}

如果一定要将列表中的某个个元素赋值为NULL，可以使用list(NULL)，比如：

{% codeblock lang:r %}
> tmp <- list()
> tmp[1] <- list(NULL)
> tmp
[[1]]
NULL
> is.null(tmp[[1]])
[1] TRUE
{% endcodeblock %}

## 3. list不是万能的，但没有list是万万不能的 ##

列表（list）在R中是个全能选手、无所不“包”；list还是金箍棒，别看它丫的开始长度（`length()`{:.language-r}）短，之后想变长就变长，多长都行。

这暗示list可以这样用：在循环开始时，我们不知道会产生多少个元素，可以事先规定输出结果为`a <- list()`{:.language-r}，之后赋值；甚至可以按照名字赋值，比如`a$add <- exprs`{:.language-r}。

* 创建

> 如果要创建一个长度为n的、每个元素都为`NULL`{:.language-r}的list，可以使用`vector("list", n)`{:.language-r}。

* 插入

> 如果要在list中插入元素，可以使用`append(x, values, after = length(x))`{:.language-r}函数。`append()`{:.language-r}函数原本是对vector设计的，但是list也能使用。

* 取值

> 对list进行取值，不能直接使用`TRUE`{:.language-r}/`FALSE`{:.language-r}向量，而是使用下标进行，可以使用`which()`{:.language-r}函数转换。

## 4. 创建“空”值很淡定，要么空来要么0 ##

如果要创建一个空的对象（对象的长度是0）很容易，比如：

* 创建一个长度为0的数值向量

> `numeric()`{:.language-r}或者`numeric(0)`{:.language-r}
>
> `character()`{:.language-r}或者`character(0)`{:.language-r}
>
> `integer()`{:.language-r}或者`integer(0)`{:.language-r}可以起到同样的效果
>
> `factor()`{:.language-r}创建一个长度为0的因子
>
> <span style="color: blue">注意</span>：`factor(0)`{:.language-r}的长度是1

* 创建一个长度为0的矩阵

> `matrix(0, 0, 0)`
>
> <span style="color: blue">注意</span>：`array()`{:.language-r}创建的对象长度为1。

* 创建一个长度为0的列表

> `list()`{:.language-r}

* 创建一个长度为0的data.frame

> `data.frame()`{:.language-r}


## 5. 对象转换要小心，data.frame是陷阱 ##

R中一些对象转换要格外小心，特别是牵扯到data.frame类型。以下是几个常见的陷阱：

### 5.1 “字符型因子”转换为“数值型向量”

需要先转成字符串向量过渡一下：

{% codeblock lang:r %}
as.numeric(as.character(MyFactor))
{% endcodeblock %}

### 5.2 字符和数值因子混搭data.frame ###

每一列是按照字符型因子保存。留意表面上是数值的一列，它非常危险，特别是排序。一个例子：

{% codeblock lang:r %}
> a1 <- as.factor(as.character(a1))
> a1
 [1] 5  6  7  8  9  10 11 12 13 14 15
Levels: 10 11 12 13 14 15 5 6 7 8 9
> sort(a1)
 [1] 10 11 12 13 14 15 5  6  7  8  9 
Levels: 10 11 12 13 14 15 5 6 7 8 9
{% endcodeblock %}

## 6. 多个`else`{:.language-r}/`if`{:.language-r}别担心，`switch()`{:.language-r}函数来帮助 ##

如果需要在不同情况下，对变量进行不同的处理，自然会联想到使用多个多个`else`{:.language-r}/`if`{:.language-r}。如果`else`{:.language-r}/`if`{:.language-r}是用来处理的简单的赋值，可以使用`switch(EXPR, ...)`{:.language-r}函数。其中，`EXPR`{:.language-r}是一个表达式，生成一个数字或者字符串；接下来，使用生成的数字和字符串匹配`...`{:.language-r}中的内容。

所以，我们很容易想到，如果`EXPR`{:.language-r}生成的数字，则对应匹配`...`{:.language-r}的第几个元素，此时`...`{:.language-r}中的变量可以没有名字；如果是字符串，就会严格地匹配`...`{:.language-r}中相同名字的变量；如果`EXPR`{:.language-r}生成是字符串，`...`{:.language-r}中没有相匹配的变量名，则返回`NULL`{:.language-r}；如果`...`{:.language-r}中有一个“无名”变量（即没有对变量赋值），上一种情况下返回该无名变量，相当于最后一个`else`{:.language-r}。比如：

{% codeblock lang:r %}
> switch(1, a = 3, b = 2)
[1] 3
> switch(2, aa = 'red', bb = 'blue', cc = 'yellow', 'No value')
[1] "blue"
> switch('aa', aa = 'red', bb = 'blue', cc = 'yellow', 'No value')
[1] "red"
> switch('dd', aa = 'red', bb = 'blue', cc = 'yellow', 'No value')
[1] "No value"
> switch('bb', aa = 'red', bb = , cc = 'yellow')
[1] "yellow"
> switch(2, aa = 'red', bb = , cc = 'yellow')
Error: empty alternative in numeric switch
> switch('dd', aa = 'red', bb = , cc = 'yellow', 'no', 'value')
Error: duplicate switch defaults: '"no"' and '"value"'
{% endcodeblock %}

<span style="color: blue">注意</span>：

* 如果`EXPR`{:.language-r}是数字，范围不能超过`...`{:.language-r}的长度。同时，虽然此时`...`{:.language-r}变量可以名字，但是有名字的变量必须有数值，不能学习以上例子中倒数第二种情况，否则会报错。

* 如果`EXPR`{:.language-r}是字符串，那么会进行自动继承，即前者继承后者。

* 虽然`EXPR`{:.language-r}是字符串情况可以自动继承，甚至继承一个无名变量，但是无名变量只能有一个。

* 最后将`EXPR`明确写出，为了R的版本兼容。

**总结**：
`swich()`{:.language-r}函数是一个好玩却又危险的函数，一个没有歧义的使用方法是：`EXPR`{:.language-r}明确写出，且返回字符串，`...`{:.language-r}中每一个变量都有确切的值，无名变量只有一个，比如：`switch(EXPR='dd', aa = 'red', bb = 'blue', cc = 'yellow', 'no value')`{:.language-r}。

## 7. R取值有技巧，`drop`{:.language-r}选项巧帮助 ##

当对象是一个矩阵的时候，通常我们要获取其中一些元素。如果取出的正好是一行或者一列，此时，R会返回给我们一个向量，而不是矩阵。这会带来很大的麻烦，因为我们必须判断返回对象是向量，还是矩阵，才能继续下面的操作。此时，`drop`{:.language-r}可以帮助我们，如果设置`drop = FALSE`{:.language-r}，就会保持原样返回结果。

{% codeblock lang:r %}
> b <- matrix(1:6, nrow = 2, ncol = 3)
> b
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6
> b[, 3]
[1] 5 6
> b[, 3, drop = FALSE]
     [,1]
[1,]    5
[2,]    6
> b[1, , drop = FALSE]
     [,1] [,2] [,3]
[1,]    1    3    5
{% endcodeblock %}

## 8. `|`{:.language-r} 和 `||`{:.language-r} 有区别，返回向量与单值 ##

R中的逻辑运算符号有两组，`|`{:.language-r}或者`||`{:.language-r}（`&`{:.language-r}或者`&&`{:.language-r}），看起来觉得有些多余。其实，这是为了R独特的“**向量运算**”考虑的。`|`{:.language-r}或者`&`{:.language-r}首先考虑返回一个向量，而`||`{:.language-r}和`&&`{:.language-r}则只返回最后一个值。比如：

{% codeblock lang:r %}
> c(FALSE, TRUE) | c(FALSE, FALSE)
[1] FALSE  TRUE
> c(FALSE, TRUE) || c(FALSE, FALSE)
[1] FALSE
{% endcodeblock %} 

## 9. 递归 ##

R在解释代码时，不支持尾递归优化，所以在R中不要写递归。

## 10. R图例空元素，`0`{:.language-r}和`NA`{:.language-r}来代替 ##

在R绘图的图例中，通常需要“线条”和“点”分开单独表示，这里用到`0`{:.language-r}和`NA`{:.language-r}的小技巧。如果在`legend()`{:.language-r}函数函数中，`pch = NA`{:.language-r}表示没有点，`lty=0`{:.language-r}表示没有线条。

## 11. 字符串转代码很容易，`eval()`{:.language-r}/`parse()`{:.language-r}很随意 ##

如果我们有一个字符字符串，现在需要将其转为可执行代码。方法如下：

{% codeblock lang:r %}
> test1 = '1:3'
> test1
[1] "1:3"
> eval(parse(text = test1))
[1] 1 2 3
{% endcodeblock %}

## 12. factor如需换标签，`c()`{:.language-r}函数有妙招 ##

如果我们需要对一个factor的标签（label）进行转换，并且返回一个向量，有两种方法可以使用:


* 第一种方法，使用`c()`函数

{% codeblock lang:r %}
> tmp1 <- factor(rep(1:3, each = 3))
> tmp1
[1] 1 1 1 2 2 2 3 3 3
Levels: 1 2 3
> c(letters[1:3])[tmp1]
[1] "a" "a" "a" "b" "b" "b" "c" "c" "c"
{% endcodeblock %}

* 第二种方法，先转换标签，之后再使用`as.character()`{:.language-r}函数。

{% codeblock lang:r %}
> tmp2 <- factor(tmp1, labels = letters[1:3])
> tmp2
[1] a a a b b b c c c
Levels: a b c
> as.character(tmp2)
[1] "a" "a" "a" "b" "b" "b" "c" "c" "c"
{% endcodeblock %}

## 13. 操作符也是函数，使用起来有妙招 ##

{% codeblock lang:r %}
> "+"(1, 2)
[1] 3
> '>'(1, 2)
[1] FALSE
> tmp1 = list()
> for(i in 1:10)
  tmp1[[i]] = i:(i+1)
> tmp1
[[1]]
[1] 1 2

[[2]]
[1] 2 3

[[3]]
[1] 3 4

[[4]]
[1] 4 5

[[5]]
[1] 5 6

[[6]]
[1] 6 7

[[7]]
[1] 7 8

[[8]]
[1] 8 9

[[9]]
[1]  9 10

[[10]]
[1] 10 11
> sapply(tmp1, '[[', 2)
 [1]  2  3  4  5  6  7  8  9 10 11
{% endcodeblock %}

最后一个例子中，使用了`[[`{:.language-r}，巧妙地取得了第二个元素。

## 14. 输出table有引号，`quote`{:.language-r}参数来帮忙 ##

在使用`write.table()`{:.language-r}命令输入一个data.frame对象时候，输入文件会加引号。这时，设定`quote`{:.language-r}参数，`write.table(..., quote = FALSE)`{:.language-r}。

## 15. 比较两个元素`identical()`{:.language-r} ##

## 16. 压缩list用`do.call()`{:.language-r} ##

{% codeblock lang:r %}
do.call(rbind, list)
{% endcodeblock %}

## 17. 分割数据使用`split()`{:.language-r} ##

{% codeblock lang:r %}
> test1 <- rep(c('a', 'b'), c(3, 4))
> test1
[1] "a" "a" "a" "b" "b" "b" "b"
> split(test1, factor(test1))
$a
[1] "a" "a" "a"

$b
[1] "b" "b" "b" "b"
{% endcodeblock %}

## 18. 输出txt文档找`sink()`{:.language-r} ##

`sink()`可以将R的对象输出到外部文档中，第一遍可能包括了系统信息，需要输出第二遍。一个典型的流程如下：

{% codeblock lang:r %}
> sink(filename)
> test1
> sink()
{% endcodeblock %}

## 19. R中循环for妙用 ##

R中for循环中，需要指定一个计数器，比如i in 1:10之类。R可以直接将一个向量用于计数，返回向量中对应的值，比如:

{% codeblock lang:r %}
> tmp1 <- letters[1:10]
for (i in tmp1) {
  print(i)
}
> [1] "a"
[1] "b"
[1] "c"
[1] "d"
[1] "e"
[1] "f"
[1] "g"
[1] "h"
[1] "i"
[1] "j"
{% endcodeblock %}

## 20. 多个序列取交集并集用`Reduce()`{:.language-r} ##

{% codeblock lang:r %}
> Reduce(union, list(letters[1:3], letters[1:4], letters[1:5]))
[1] "a" "b" "c" "d" "e"
{% endcodeblock %}

## 21. 载入github储存的R代码使用`source_url`{:.language-r} ##

需要安装和调用[devtools](http://cran.r-project.org/web/packages/devtools/index.html)包

{% codeblock lang:R Load the R code from web url %}
> library(devtools)
> source_url('https://raw.githubusercontent.com/YulongNiu/FunFunc/master/test_two_proportion.R')
{% endcodeblock %}




### <a id="Ref">参考网址</a> ###

* [R中的if/else](https://stat.ethz.ch/pipermail/r-help/attachments/20030506/ba1b4515/attachment.pl)

* 建立长度为0的对象：[1](http://cos.name/cn/topic/105751), [2](http://cran.r-project.org/doc/contrib/Genolini-S4tutorialV0-5en.pdf)

* R中其他令人迷惑的地方：[1](http://ygc.name/2012/07/10/tricky-things-in-r/)，[2](http://cos.name/cn/topic/17000#post-17000)


### 更新记录 ###

2015年7月11日
